<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>图谱可视化</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="/static/js/app-shell.js"></script>
    <script src="/static/js/ui-cards.js"></script>
    <script src="/static/js/doc-card.js"></script>
    <script src="/static/js/graph-viewer.js"></script>
    <style>
      * { box-sizing: border-box; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Noto Sans SC", sans-serif;
        margin: 0;
        padding: 24px;
        background: #f8fafc;
        color: #1e293b;
        line-height: 1.6;
      }
      body.in-iframe header { margin-bottom: 0; border-radius: 0; }
      .container { max-width: 100%; margin: 0 auto; width: 100%; }
      header {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      h1 { margin: 0 0 8px 0; font-size: 28px; color: #0f172a; }
      header p { margin: 0; color: #64748b; }
      .controls {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      .controls-row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; margin-bottom: 16px; }
      .controls-row:last-child { margin-bottom: 0; }
      .controls label { font-weight: 500; color: #475569; white-space: nowrap; }
      .controls input, .controls select {
        padding: 8px 12px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
        font-family: inherit;
      }
      .controls input[type="date"] { min-width: 160px; }
      .controls input[type="number"] { width: 100px; }
      .controls button {
        padding: 8px 16px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      .controls button:hover { background: #1d4ed8; }
      .controls button.secondary { background: #64748b; }
      .filter-extra { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
      .mode-switch { display: inline-flex; align-items: center; gap: 8px; }
      .mode-switch select { min-width: 140px; }
      .ingest-dashboard {
        margin-top: 6px;
        border: 1px solid #dbeafe;
        background: #f8fbff;
        border-radius: 10px;
        padding: 12px;
        width: 100%;
      }
      .ingest-dashboard h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #0f172a;
      }
      .ingest-dashboard-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 10px 12px;
      }
      .ingest-dashboard-item { display: flex; flex-direction: column; gap: 4px; }
      .ingest-dashboard-item label { font-size: 12px; color: #475569; }
      .ingest-dashboard-item input[type="text"],
      .ingest-dashboard-item input[type="number"] { width: 100%; }
      .ingest-dashboard-item.checkbox { flex-direction: row; align-items: center; gap: 6px; }
      .ingest-dashboard-item.checkbox label { margin: 0; }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
        margin-bottom: 14px;
      }
      .stat-card {
        background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
        padding: 12px 14px;
        border-radius: 10px;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
        border: 1px solid #e7edf5;
        border-left: 3px solid #3b82f6;
        min-height: 72px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .stat-card h3 {
        margin: 0 0 4px 0;
        font-size: 11px;
        color: #64748b;
        font-weight: 600;
        letter-spacing: 0.02em;
        line-height: 1.25;
      }
      .stat-card .value {
        font-size: 24px;
        font-weight: 800;
        color: #0f172a;
        line-height: 1;
      }
      .graph-container {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
        position: relative;
      }
      .graph-container h2 {
        margin: 0 0 16px 0;
        font-size: 18px;
        color: #0f172a;
        border-bottom: 2px solid #e2e8f0;
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .graph-header-actions { display: flex; gap: 8px; align-items: center; }
      .fullscreen-btn {
        padding: 6px 12px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .fullscreen-btn:hover { background: #1d4ed8; }
      .graph-control-panel {
        position: absolute;
        left: 16px;
        bottom: 16px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
        row-gap: 8px;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.92);
        border-radius: 12px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.12);
        z-index: 20;
        backdrop-filter: blur(4px);
        max-width: calc(100% - 32px);
      }
      .graph-control-panel label { font-size: 12px; color: #475569; white-space: nowrap; }
      .graph-control-panel input[type="range"] {
        width: 132px;
        min-width: 110px;
        height: 18px;
        background: transparent;
        accent-color: #2563eb;
        -webkit-appearance: none;
        appearance: none;
      }
      .graph-control-panel input[type="range"]::-webkit-slider-runnable-track {
        height: 4px;
        border-radius: 999px;
        background: linear-gradient(90deg, #dbeafe, #93c5fd);
      }
      .graph-control-panel input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        margin-top: -5px;
        border-radius: 50%;
        background: #2563eb;
        border: 2px solid #ffffff;
        box-shadow: 0 1px 3px rgba(37, 99, 235, 0.35);
      }
      .graph-control-panel input[type="range"]::-moz-range-track {
        height: 4px;
        border-radius: 999px;
        background: linear-gradient(90deg, #dbeafe, #93c5fd);
      }
      .graph-control-panel input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #2563eb;
        border: 2px solid #ffffff;
        box-shadow: 0 1px 3px rgba(37, 99, 235, 0.35);
      }
      .graph-control-panel span { min-width: 36px; text-align: right; font-size: 13px; font-weight: 600; color: #2563eb; }
      .graph-control-panel .control-toggle { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #475569; white-space: nowrap; }
      .graph-control-panel .control-toggle input { accent-color: #2563eb; }
      .control-btn {
        border: 1px solid #cbd5e1;
        background: #ffffff;
        color: #334155;
        border-radius: 8px;
        padding: 4px 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .control-btn.primary {
        background: #2563eb;
        border-color: #1d4ed8;
        color: #ffffff;
      }
      .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .graph-control-panel .selection-count {
        min-width: auto;
        font-size: 12px;
        color: #0f172a;
        font-weight: 600;
      }
      .legend { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; color: #475569; font-size: 13px; align-items: flex-start; }
      .legend-group { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 6px 8px; }
      .legend-group:not(.collapsed) { flex: 1 1 100%; width: 100%; }
      .legend-group.collapsed { flex: 0 0 auto; width: auto; padding: 4px 8px; }
      .legend-group.collapsed .legend-group-items { display: none; }
      .legend-group.collapsed .legend-group-actions { display: none; }
      .legend-group.collapsed .legend-group-title { font-weight: 600; font-size: 12px; }
      .legend-group.collapsed .legend-group-title span:first-child { font-size: 11px; }
      .legend-group-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
      .legend-group-title { font-weight: 700; color: #334155; display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; }
      .legend-group-actions { display: flex; align-items: center; gap: 6px; }
      .legend-group-btn { border: 1px solid #cbd5e1; background: #fff; color: #334155; border-radius: 8px; padding: 2px 8px; font-size: 12px; cursor: pointer; }
      .legend-group-btn.is-off { background: #fee2e2; border-color: #fecaca; color: #991b1b; }
      .legend-group-items { display: grid; grid-template-columns: 1fr; gap: 6px; margin-top: 6px; }
      .legend-item { display: flex; align-items: center; gap: 6px; width: 100%; background: #f1f5f9; padding: 5px 8px; border-radius: 8px; border: 1px solid transparent; cursor: pointer; user-select: none; line-height: 1.1; }
      .legend-item.is-hidden { opacity: 0.45; background: #f8fafc; border-color: #e2e8f0; text-decoration: line-through; }
      .legend-symbol { width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; position: relative; }
      .legend-symbol-shape { width: 12px; height: 12px; display: block; background: currentColor; }
      .legend-symbol-shape.circle { border-radius: 999px; }
      .legend-symbol-shape.emptyCircle { border-radius: 999px; background: transparent; border: 2px solid currentColor; box-sizing: border-box; }
      .legend-symbol-shape.roundRect { border-radius: 4px; }
      .legend-symbol-shape.emptyRoundRect { border-radius: 4px; background: transparent; border: 2px solid currentColor; box-sizing: border-box; }
      .legend-symbol-shape.rect { border-radius: 0; }
      .legend-symbol-shape.emptyRect { border-radius: 0; background: transparent; border: 2px solid currentColor; box-sizing: border-box; }
      .legend-symbol-shape.diamond { transform: rotate(45deg) scale(0.9); border-radius: 1px; }
      .legend-symbol-shape.emptyDiamond { transform: rotate(45deg) scale(0.9); border-radius: 1px; background: transparent; border: 2px solid currentColor; box-sizing: border-box; }
      .legend-symbol-shape.triangle { width: 0; height: 0; background: transparent; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 12px solid currentColor; }
      .legend-symbol-shape.emptyTriangle { width: 0; height: 0; background: transparent; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 12px solid currentColor; filter: drop-shadow(0 0 0 currentColor); }
      .legend-symbol-shape.pin { width: 10px; height: 10px; border-radius: 999px; }
      .legend-symbol-shape.pin::after { content: ""; position: absolute; left: 5px; top: 8px; width: 2px; height: 6px; background: currentColor; transform: rotate(20deg); border-radius: 1px; }
      .legend-symbol-shape.emptyPin { width: 10px; height: 10px; border-radius: 999px; background: transparent; border: 2px solid currentColor; box-sizing: border-box; }
      .legend-symbol-shape.emptyPin::after { content: ""; position: absolute; left: 5px; top: 8px; width: 2px; height: 6px; background: currentColor; transform: rotate(20deg); border-radius: 1px; }
      .legend-symbol-shape.arrow { width: 0; height: 0; background: transparent; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-left: 12px solid currentColor; }
      .legend-symbol-shape.emptyArrow { width: 0; height: 0; background: transparent; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-left: 12px solid currentColor; opacity: 0.8; }
      #graph-chart { width: 100%; height: 720px; min-height: 500px; }
      #graph-fullscreen-view { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 10000; background: white; padding: 20px; box-sizing: border-box; }
      #graph-fullscreen-view.active { display: block; }
      #graph-fullscreen-view .graph-container { height: 100%; margin: 0; border-radius: 0; box-shadow: none; }
      #fullscreen-graph-chart { width: 100%; height: calc(100vh - 90px); min-height: 500px; }
      .info { background: #eff6ff; border: 1px solid #bfdbfe; color: #1e40af; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
      .error { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
      .loading { display: flex; align-items: center; justify-content: center; color: #64748b; padding: 40px 0; }
      .spinner { display: inline-block; width: 18px; height: 18px; border: 3px solid #cbd5e1; border-top-color: #2563eb; border-radius: 50%; animation: spin 0.6s linear infinite; margin-right: 8px; }
      @keyframes spin { to { transform: rotate(360deg); } }
      .details-panel {
        display: none;
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        z-index: 10001;
        background: rgba(15,23,42,0.4);
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
      }
      .details-panel.active { display: flex; }
      .details-panel .modal-content {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        max-width: 560px;
        max-height: 80vh;
        overflow: auto;
        position: relative;
      }
      .details-panel h3 { margin: 0 0 12px 0; font-size: 18px; color: #0f172a; padding-right: 32px; }
      .details-panel .modal-close {
        position: absolute;
        top: 16px;
        right: 16px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #64748b;
        line-height: 1;
        padding: 4px;
      }
      .details-panel .modal-close:hover { color: #0f172a; }
      .details-panel .detail-body { background: #f8fafc; padding: 16px; border-radius: 8px; overflow-y: auto; font-size: 14px; max-height: 400px; margin: 0; }
      .details-panel .info-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; margin-bottom: 12px; }
      .details-panel .info-item { background: white; padding: 10px; border-radius: 6px; border: 1px solid #e5e7eb; }
      .details-panel .info-item label { display: block; font-size: 12px; color: #6b7280; margin-bottom: 4px; }
      .details-panel .info-item .value { font-size: 14px; color: #1f2937; font-weight: 500; }
      .details-panel .tag-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
      .details-panel .tag-item { background: white; padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: 500; border: 1px solid #e5e7eb; }
      .details-panel .badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 500; }
      .details-panel .badge.positive { background: #dcfce7; color: #166534; }
      .details-panel .badge.negative { background: #fee2e2; color: #991b1b; }
      .details-panel .badge.neutral { background: #f1f5f9; color: #475569; }
      .details-panel .extracted-card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-top: 12px; }
      .details-panel .extracted-section { margin-bottom: 16px; }
      .details-panel .extracted-section h3 { margin: 0 0 8px 0; font-size: 14px; color: #64748b; font-weight: 600; }
      .details-panel .content-preview { max-height: 200px; overflow-y: auto; padding: 12px; background: white; border-radius: 6px; white-space: pre-wrap; font-size: 12px; margin-top: 8px; }
      .details-panel .relation-list { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; }
      .details-panel .relation-item { background: white; padding: 10px; border-radius: 6px; border: 1px solid #e5e7eb; font-size: 13px; }
      .details-panel .link { color: #2563eb; text-decoration: none; word-break: break-all; }
      .details-panel .link:hover { text-decoration: underline; }
      .selection-export-panel {
        display: none;
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        z-index: 10002;
        background: rgba(15,23,42,0.45);
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
      }
      .selection-export-panel.active { display: flex; }
      .selection-export-panel .modal-content {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        width: min(780px, 100%);
        max-height: 85vh;
        overflow: auto;
        position: relative;
      }
      .selection-export-panel h3 { margin: 0 0 8px 0; font-size: 18px; color: #0f172a; padding-right: 32px; }
      .selection-export-panel .modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #64748b;
        line-height: 1;
        padding: 4px;
      }
      .selection-export-panel .modal-close:hover { color: #0f172a; }
      .selection-export-panel .hint { color: #64748b; font-size: 12px; margin-bottom: 8px; }
      .selection-export-panel .preview,
      .selection-export-panel .result-summary {
        margin-top: 10px;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
        border-radius: 8px;
        padding: 10px;
        font-size: 12px;
        color: #334155;
      }
      .selection-export-panel .preview h4,
      .selection-export-panel .result-summary h4 { margin: 0 0 8px 0; font-size: 13px; color: #0f172a; }
      .selection-export-panel .batch-list { display: flex; flex-direction: column; gap: 8px; }
      .selection-export-panel .batch-item { background: #ffffff; border: 1px solid #dbeafe; border-radius: 6px; padding: 8px; }
      .selection-export-panel textarea {
        width: 100%;
        min-height: 180px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        padding: 10px;
        resize: vertical;
      }
      .selection-export-panel .actions {
        margin-top: 10px;
        display: flex;
        gap: 8px;
        justify-content: flex-end;
      }
      @media (max-width: 768px) { body { padding: 16px; } header { padding: 20px; } .controls { padding: 16px; } .graph-container { padding: 16px; } }
    </style>
  </head>
  <body>
    <script>
      if (window.self !== window.top) document.body.classList.add('in-iframe');
    </script>
    <div class="container">
      <header>
        <h1 id="graph-page-title">图谱可视化</h1>
        <p id="graph-doc-type-hint" class="info" style="margin-top: 12px;"></p>
        <p id="graph-structure-hint" class="info" style="margin-top: 8px;"></p>
      </header>

      <div class="controls">
        <div class="controls-row">
          <label>开始日期：</label>
          <input type="date" id="filter-start" />
          <label>结束日期：</label>
          <input type="date" id="filter-end" />
          <span class="filter-extra" id="filter-extra"></span>
          <label>数量限制：</label>
          <input type="number" id="filter-limit" min="1" max="500" value="100" />
          <button id="apply-btn">应用筛选</button>
          <button id="reset-btn" class="secondary">重置</button>
        </div>
        <div class="controls-row">
          <span class="mode-switch">
            <label for="graph-mode-select">图谱模式：</label>
            <select id="graph-mode-select">
              <option value="browse">浏览模式</option>
              <option value="collect">采集模式</option>
            </select>
          </span>
        </div>
        <div class="ingest-dashboard" id="ingest-dashboard" style="display:none;">
          <h3>采集仪表板参数</h3>
          <div class="ingest-dashboard-grid">
            <div class="ingest-dashboard-item"><label for="dashboard-language">language</label><input type="text" id="dashboard-language" value="en" /></div>
            <div class="ingest-dashboard-item"><label for="dashboard-provider">provider</label><input type="text" id="dashboard-provider" value="auto" /></div>
            <div class="ingest-dashboard-item"><label for="dashboard-max-items">max_items</label><input type="number" id="dashboard-max-items" value="100" min="1" max="100" /></div>
            <div class="ingest-dashboard-item"><label for="dashboard-start-offset">start_offset</label><input type="number" id="dashboard-start-offset" value="" min="1" /></div>
            <div class="ingest-dashboard-item"><label for="dashboard-days-back">days_back</label><input type="number" id="dashboard-days-back" value="7" min="0" max="365" /></div>
            <div class="ingest-dashboard-item"><label for="dashboard-platforms">platforms (comma-separated)</label><input type="text" id="dashboard-platforms" value="reddit" /></div>
            <div class="ingest-dashboard-item"><label for="dashboard-base-subreddits">base_subreddits (comma-separated)</label><input type="text" id="dashboard-base-subreddits" value="" /></div>
            <div class="ingest-dashboard-item checkbox"><input type="checkbox" id="dashboard-enable-extraction" checked /><label for="dashboard-enable-extraction">enable_extraction</label></div>
            <div class="ingest-dashboard-item checkbox"><input type="checkbox" id="dashboard-async-mode" checked /><label for="dashboard-async-mode">async_mode</label></div>
            <div class="ingest-dashboard-item checkbox"><input type="checkbox" id="dashboard-enable-subreddit-discovery" /><label for="dashboard-enable-subreddit-discovery">enable_subreddit_discovery</label></div>
            <div class="ingest-dashboard-item checkbox"><input type="checkbox" id="dashboard-llm-assist" checked /><label for="dashboard-llm-assist">llm_assist</label></div>
          </div>
        </div>
      </div>

      <div class="stats" id="stats"></div>
      <div id="message-area"></div>

      <div class="graph-container" data-role="main">
        <div class="graph-control-panel" id="graph-control-panel">
          <label for="repulsion-slider">节点斥力</label>
          <input type="range" id="repulsion-slider" min="0" max="720" step="10" value="180" />
          <span id="repulsion-value">180</span>
          <label for="node-scale-slider">节点尺寸</label>
          <input type="range" id="node-scale-slider" min="0" max="180" step="5" value="100" />
          <span id="node-scale-value">100%</span>
          <label for="legend-lang-select">图例语言</label>
          <select id="legend-lang-select">
            <option value="zh">中文</option>
            <option value="en">English</option>
          </select>
          <label class="control-toggle">
            <input type="checkbox" id="label-toggle" checked />
            显示标签
          </label>
          <label class="control-toggle">
            <input type="checkbox" id="selection-toggle" />
            选择模式
          </label>
          <span class="selection-count" id="selection-count">已选 0</span>
          <button type="button" class="control-btn" id="selection-clear-btn" disabled>清空</button>
          <button type="button" class="control-btn primary" id="selection-export-btn" disabled>结构化任务</button>
        </div>
        <h2>
          <span id="graph-title">知识图谱</span>
          <span class="graph-header-actions">
            <button type="button" class="fullscreen-btn" id="fullscreen-btn">全屏查看</button>
            <button type="button" class="fullscreen-btn secondary" id="refresh-btn">刷新</button>
          </span>
        </h2>
        <div class="legend" id="legend"></div>
        <div id="graph-chart">
          <div class="loading"><span class="spinner"></span>加载中...</div>
        </div>
      </div>

      <div class="details-panel" id="details-panel">
        <div class="modal-content">
          <h3 id="details-title">节点详情</h3>
          <button type="button" class="modal-close" id="details-close-btn" aria-label="关闭">&times;</button>
          <div id="details-content" class="detail-body"></div>
        </div>
      </div>

      <div class="selection-export-panel" id="selection-export-panel">
        <div class="modal-content">
          <h3>结构化搜索任务</h3>
          <button type="button" class="modal-close" id="selection-export-close-btn" aria-label="关闭">&times;</button>
          <p class="hint">单击只点亮节点，双击点亮节点及一跳邻居。可复制结构化任务 JSON，或直接生成结构化任务并提交。</p>
          <textarea id="selection-export-text" readonly></textarea>
          <div class="preview" id="structured-task-preview"></div>
          <div class="result-summary" id="structured-task-result"></div>
          <div class="actions">
            <button type="button" class="control-btn" id="selection-copy-btn">复制结构化任务JSON</button>
            <button type="button" class="control-btn primary" id="selection-send-collect-btn">生成结构化采集任务</button>
            <button type="button" class="control-btn primary" id="selection-send-source-btn">生成来源采集任务</button>
          </div>
        </div>
      </div>
    </div>

    <div id="graph-fullscreen-view">
      <div class="graph-container" data-role="fullscreen">
        <h2>
          <span id="fullscreen-title">知识图谱（全屏）</span>
          <span class="graph-header-actions">
            <button type="button" class="fullscreen-btn secondary" id="fullscreen-refresh-btn">刷新</button>
            <button type="button" class="fullscreen-btn" id="exit-fullscreen-btn">退出全屏</button>
          </span>
        </h2>
        <div class="legend" id="fullscreen-legend"></div>
        <div id="fullscreen-graph-chart"></div>
      </div>
    </div>

    <script>
      const GV = window.GraphViewer;
      const typeParam = new URLSearchParams(window.location.search).get('type') || 'policy';
      const graphType = ['policy', 'social', 'market', 'market_deep_entities', 'company', 'product', 'operation'].includes(typeParam) ? typeParam : 'policy';

      const messageArea = document.getElementById('message-area');
      const detailsPanel = document.getElementById('details-panel');
      const detailsTitle = document.getElementById('details-title');
      const detailsContent = document.getElementById('details-content');
      const limitInput = document.getElementById('filter-limit');
      const repulsionSlider = document.getElementById('repulsion-slider');
      const repulsionValueEl = document.getElementById('repulsion-value');
      const nodeScaleSlider = document.getElementById('node-scale-slider');
      const nodeScaleValueEl = document.getElementById('node-scale-value');
      const legendLangSelect = document.getElementById('legend-lang-select');
      const labelToggle = document.getElementById('label-toggle');
      const selectionToggle = document.getElementById('selection-toggle');
      const selectionCountEl = document.getElementById('selection-count');
      const selectionClearBtn = document.getElementById('selection-clear-btn');
      const selectionExportBtn = document.getElementById('selection-export-btn');
      const selectionExportPanel = document.getElementById('selection-export-panel');
      const selectionExportText = document.getElementById('selection-export-text');
      const structuredTaskPreviewEl = document.getElementById('structured-task-preview');
      const structuredTaskResultEl = document.getElementById('structured-task-result');
      const graphModeSelect = document.getElementById('graph-mode-select');
      const ingestDashboardEl = document.getElementById('ingest-dashboard');
      const graphControlPanel = document.getElementById('graph-control-panel');
      const mainGraphContainer = document.querySelector('.graph-container[data-role="main"]');
      const fullscreenGraphContainer = document.querySelector('#graph-fullscreen-view .graph-container[data-role="fullscreen"]');

      let graphChart = null;
      let fullscreenChart = null;
      let isFullscreen = false;
      let latestGraphData = null;
      let currentRepulsion = Number(repulsionSlider?.value || 180);
      let nodeScaleFactor = Number(nodeScaleSlider?.value || 100) / 100;
      let showLabels = labelToggle ? labelToggle.checked : true;
      let legendLang = (localStorage.getItem('graphLegendLang') || 'zh') === 'en' ? 'en' : 'zh';
      let graphConfig = { nodeTypes: [], nodeLabels: {}, nodeColors: {}, nodeSymbols: {}, nodeSizeRules: {} };
      const LEGEND_ZH_LABELS_FALLBACK = {
        MarketData: '市场数据',
        State: '地区',
        Segment: '品类',
        Game: '游戏',
        Entity: '实体',
        Policy: '政策',
        PolicyType: '政策类型',
        KeyPoint: '要点',
        Post: '帖子',
        Keyword: '关键词',
        Topic: '主题',
        TopicTag: '专题标签',
        SentimentTag: '情感标签',
        User: '用户',
        Subreddit: '社区',
        CompanyEntity: '公司主体',
        CompanyBrand: '公司品牌',
        CompanyUnit: '业务单元',
        CompanyPartner: '合作方',
        CompanyChannel: '公司渠道',
        ProductEntity: '商品主体',
        ProductModel: '商品型号',
        ProductCategory: '商品品类',
        ProductBrand: '商品品牌',
        ProductComponent: '商品组件',
        ProductScenario: '适用场景',
        OperationEntity: '经营主体',
        OperationPlatform: '经营平台',
        OperationStore: '店铺',
        OperationChannel: '经营渠道',
        OperationMetric: '经营指标',
        OperationStrategy: '经营策略',
        OperationRegion: '经营区域',
        OperationPeriod: '经营周期',
      };
      const hiddenNodeTypes = new Set();
      const collapsedLegendGroups = new Set(['company', 'product', 'operation', 'other']);
      const nodeLayoutCache = new Map();
      const selectedNodeKeys = new Set();
      let selectionEnabled = false;
      let adjacencyIndex = new Map();
      let lastSelectionExportPayload = null;
      let currentGraphMode = 'browse';
      let nodeClickTimer = null;
      let currentFilteredGraphData = { nodes: [], edges: [] };
      const FALLBACK_TYPE_COLORS = ['#2563eb', '#0ea5e9', '#22c55e', '#f97316', '#a855f7', '#ec4899', '#14b8a6', '#f59e0b', '#64748b', '#06b6d4'];
      const FALLBACK_TYPE_SYMBOLS = ['circle', 'roundRect', 'diamond', 'rect', 'triangle', 'pin'];

      const EXTRA_FILTERS = {
        policy: () => `
          <label>州：</label>
          <select id="filter-state">
            <option value="">全部</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
            <option value="FL">FL</option>
            <option value="IL">IL</option>
          </select>
          <label>政策类型：</label>
          <select id="filter-type">
            <option value="">全部</option>
            <option value="regulation">法规</option>
            <option value="bill">法案</option>
            <option value="announcement">公告</option>
          </select>
        `,
        social: () => `
          <label>平台：</label>
          <select id="filter-platform">
            <option value="">全部</option>
            <option value="reddit">Reddit</option>
            <option value="twitter">Twitter</option>
          </select>
          <label>主题：</label>
          <input type="text" id="filter-topic" placeholder="可选" />
        `,
        market: () => `
          <label>视图：</label>
          <select id="filter-market-view">
            <option value="market">标准图谱</option>
            <option value="market_deep_entities">实体加细图</option>
          </select>
          <label>州：</label>
          <select id="filter-state">
            <option value="">全部</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
          </select>
          <label>游戏：</label>
          <input type="text" id="filter-game" placeholder="可选" />
        `,
        market_deep_entities: () => `
          <label>视图：</label>
          <select id="filter-market-view">
            <option value="market">标准图谱</option>
            <option value="market_deep_entities">实体加细图</option>
          </select>
          <label>州：</label>
          <select id="filter-state">
            <option value="">全部</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
          </select>
          <label>游戏：</label>
          <input type="text" id="filter-game" placeholder="可选" />
        `,
        company: () => `
          <label>州：</label>
          <select id="filter-state">
            <option value="">全部</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
          </select>
          <label>游戏：</label>
          <input type="text" id="filter-game" placeholder="可选" />
        `,
        product: () => `
          <label>州：</label>
          <select id="filter-state">
            <option value="">全部</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
          </select>
          <label>游戏：</label>
          <input type="text" id="filter-game" placeholder="可选" />
        `,
        operation: () => `
          <label>州：</label>
          <select id="filter-state">
            <option value="">全部</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
          </select>
          <label>游戏：</label>
          <input type="text" id="filter-game" placeholder="可选" />
        `
      };

      function getFilterValues() {
        const v = {
          start_date: document.getElementById('filter-start')?.value || '',
          end_date: document.getElementById('filter-end')?.value || '',
          limit: limitInput?.value || '100'
        };
        if (graphType === 'policy') {
          v.state = document.getElementById('filter-state')?.value || '';
          v.policy_type = document.getElementById('filter-type')?.value || '';
        } else if (graphType === 'social') {
          v.platform = document.getElementById('filter-platform')?.value || '';
          v.topic = document.getElementById('filter-topic')?.value?.trim() || '';
        } else if (graphType === 'market' || graphType === 'market_deep_entities' || graphType === 'company' || graphType === 'product' || graphType === 'operation') {
          v.state = document.getElementById('filter-state')?.value || '';
          v.game = document.getElementById('filter-game')?.value?.trim() || '';
        }
        return v;
      }

      function renderExtraFilters() {
        const el = document.getElementById('filter-extra');
        if (el) el.innerHTML = EXTRA_FILTERS[graphType]?.() || '';
        const marketViewEl = document.getElementById('filter-market-view');
        if (marketViewEl) marketViewEl.value = graphType === 'market_deep_entities' ? 'market_deep_entities' : 'market';
      }

      function showMessage(type, text) {
        messageArea.innerHTML = '';
        if (!text) return;
        const div = document.createElement('div');
        div.className = type === 'error' ? 'error' : 'info';
        div.textContent = text;
        messageArea.appendChild(div);
      }

      function keyOfNode(node) {
        return `${node?.type}:${node?.id}`;
      }

      function buildSelectionIndex(data) {
        const index = new Map();
        const edges = data?.edges || [];
        for (const edge of edges) {
          const fromKey = edge?.from ? `${edge.from.type}:${edge.from.id}` : '';
          const toKey = edge?.to ? `${edge.to.type}:${edge.to.id}` : '';
          if (!fromKey || !toKey) continue;
          if (!index.has(fromKey)) index.set(fromKey, new Set());
          if (!index.has(toKey)) index.set(toKey, new Set());
          index.get(fromKey).add(toKey);
          index.get(toKey).add(fromKey);
        }
        return index;
      }

      function getSelectedLabel(node) {
        return String(node?.title || node?.name || node?.text || node?.canonical_name || `${node?.type}:${node?.id}` || '').trim();
      }

      function buildSelectionExportPayload() {
        const nodes = currentFilteredGraphData?.nodes || [];
        const edges = currentFilteredGraphData?.edges || [];
        const nodeByKey = new Map(nodes.map((n) => [keyOfNode(n), n]));
        const selectedNodes = Array.from(selectedNodeKeys).map((key) => nodeByKey.get(key)).filter(Boolean);
        const selectedSet = new Set(selectedNodes.map((n) => keyOfNode(n)));
        const selectedEdges = edges.filter((e) => selectedSet.has(`${e.from?.type}:${e.from?.id}`) && selectedSet.has(`${e.to?.type}:${e.to?.id}`));
        const dashboard = getDashboardParams();
        const llmAssist = !!document.getElementById('dashboard-llm-assist')?.checked;
        return {
          project_key: window.MarketApp?.getProjectKey?.() || '',
          graph_type: graphType,
          mode: currentGraphMode,
          selected_count: selectedNodes.length,
          edge_count: selectedEdges.length,
          dashboard,
          llm_assist: llmAssist,
          selected_nodes: selectedNodes.map((node) => ({
            type: node.type,
            id: node.id,
            entry_id: node.id,
            label: getSelectedLabel(node)
          })),
          edges: selectedEdges.map((edge) => ({
            type: edge.type,
            from: edge.from,
            to: edge.to
          }))
        };
      }

      function renderSelectionExportText(payload) {
        if (!selectionExportText) return;
        selectionExportText.value = JSON.stringify(payload || {}, null, 2);
      }

      function updateSelectionUiState() {
        const count = selectedNodeKeys.size;
        if (selectionCountEl) selectionCountEl.textContent = `已选 ${count}`;
        if (selectionClearBtn) selectionClearBtn.disabled = count === 0;
        if (selectionExportBtn) selectionExportBtn.disabled = count === 0;
      }

      function clearSelection({ rerender = true } = {}) {
        selectedNodeKeys.clear();
        lastSelectionExportPayload = null;
        updateSelectionUiState();
        if (rerender && latestGraphData) updateHiddenTypeVisibility();
      }

      function openSelectionExportPanel() {
        if (!selectionExportPanel) return;
        lastSelectionExportPayload = buildSelectionExportPayload();
        renderSelectionExportText(lastSelectionExportPayload);
        renderStructuredTaskPreview(lastSelectionExportPayload);
        renderStructuredTaskResult(null);
        selectionExportPanel.classList.add('active');
      }

      function closeSelectionExportPanel() {
        if (!selectionExportPanel) return;
        selectionExportPanel.classList.remove('active');
      }

      async function copySelectionToClipboard() {
        if (!lastSelectionExportPayload) lastSelectionExportPayload = buildSelectionExportPayload();
        const text = JSON.stringify(lastSelectionExportPayload, null, 2);
        try {
          await navigator.clipboard.writeText(text);
          showMessage('info', `已复制 ${lastSelectionExportPayload.selected_count || 0} 个节点的结构化任务 JSON 到剪贴板。`);
          return;
        } catch (_) {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            document.execCommand('copy');
            showMessage('info', `已复制 ${lastSelectionExportPayload.selected_count || 0} 个节点的结构化任务 JSON 到剪贴板。`);
          } catch (err) {
            showMessage('error', `复制失败: ${err?.message || '请手动复制导出文本。'}`);
          } finally {
            document.body.removeChild(textarea);
          }
        }
      }

      function parseCommaSeparated(value) {
        return String(value || '')
          .split(',')
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function getDashboardParams() {
        const maxItemsRaw = Number(document.getElementById('dashboard-max-items')?.value || 100);
        const maxItems = Number.isFinite(maxItemsRaw) ? Math.min(Math.max(Math.trunc(maxItemsRaw), 1), 100) : 100;
        const startOffsetRaw = Number(document.getElementById('dashboard-start-offset')?.value);
        const startOffset = Number.isFinite(startOffsetRaw) && startOffsetRaw > 0 ? Math.trunc(startOffsetRaw) : null;
        const daysBackRaw = Number(document.getElementById('dashboard-days-back')?.value || 7);
        const daysBackNormalized = Number.isFinite(daysBackRaw) ? Math.min(Math.trunc(daysBackRaw), 365) : 7;
        const platforms = parseCommaSeparated(document.getElementById('dashboard-platforms')?.value || '');
        const baseSubreddits = parseCommaSeparated(document.getElementById('dashboard-base-subreddits')?.value || '');
        return {
          language: document.getElementById('dashboard-language')?.value?.trim() || 'en',
          provider: document.getElementById('dashboard-provider')?.value?.trim() || 'auto',
          max_items: maxItems,
          start_offset: startOffset,
          days_back: daysBackNormalized > 0 ? daysBackNormalized : null,
          enable_extraction: !!document.getElementById('dashboard-enable-extraction')?.checked,
          async_mode: !!document.getElementById('dashboard-async-mode')?.checked,
          platforms: platforms.length ? platforms : ['reddit'],
          enable_subreddit_discovery: !!document.getElementById('dashboard-enable-subreddit-discovery')?.checked,
          base_subreddits: baseSubreddits.length ? baseSubreddits : null,
        };
      }

      function splitPreviewBatches(selectedNodes, batchSize = 10) {
        const batches = [];
        for (let i = 0; i < selectedNodes.length; i += batchSize) {
          batches.push(selectedNodes.slice(i, i + batchSize));
        }
        return batches;
      }

      function renderStructuredTaskPreview(payload) {
        if (!structuredTaskPreviewEl) return;
        const selectedNodes = Array.isArray(payload?.selected_nodes) ? payload.selected_nodes : [];
        if (!selectedNodes.length) {
          structuredTaskPreviewEl.innerHTML = '<h4>结构化任务预览（按批次）</h4><div>暂无可提交节点。</div>';
          return;
        }
        const batches = splitPreviewBatches(selectedNodes, 10);
        structuredTaskPreviewEl.innerHTML = `<h4>结构化任务预览（按批次）</h4>
          <div class="batch-list">
            ${batches.map((items, idx) => `<div class="batch-item"><strong>批次 ${idx + 1}</strong>（${items.length}）<div>${items.map((n) => escapeHtml(`${n.type}:${n.id} ${n.label || ''}`)).join('<br/>')}</div></div>`).join('')}
          </div>`;
      }

      function renderStructuredTaskResult(result) {
        if (!structuredTaskResultEl) return;
        if (!result) {
          structuredTaskResultEl.innerHTML = '<h4>执行结果摘要</h4><div>尚未提交。</div>';
          return;
        }
        const summary = result.summary || result.execution_summary || {};
        const batches = Array.isArray(result.batches) ? result.batches : (Array.isArray(result.structured_tasks) ? result.structured_tasks : []);
        const batchNames = batches
          .map((batch, idx) => batch?.batch_name || batch?.name || batch?.title || `批次 ${idx + 1}`)
          .filter(Boolean);
        structuredTaskResultEl.innerHTML = `<h4>执行结果摘要</h4>
          <div>status: ${escapeHtml(String(result.status || 'ok'))}</div>
          <div>flow_type: ${escapeHtml(String(result.flow_type || '-'))}</div>
          <div>accepted: ${escapeHtml(String(summary.accepted ?? result.accepted ?? '-'))}</div>
          <div>queued: ${escapeHtml(String(summary.queued ?? result.queued ?? '-'))}</div>
          <div>failed: ${escapeHtml(String(summary.failed ?? result.failed ?? '-'))}</div>
          <div>batches: ${batches.length}</div>
          <div>batch_names: ${escapeHtml(batchNames.join(', ') || '-')}</div>`;
      }

      function setGraphMode(mode) {
        currentGraphMode = mode === 'collect' ? 'collect' : 'browse';
        if (graphModeSelect && graphModeSelect.value !== currentGraphMode) {
          graphModeSelect.value = currentGraphMode;
        }
        if (ingestDashboardEl) ingestDashboardEl.style.display = currentGraphMode === 'collect' ? 'block' : 'none';
        const submitCollectBtn = document.getElementById('selection-send-collect-btn');
        const submitSourceBtn = document.getElementById('selection-send-source-btn');
        if (submitCollectBtn) submitCollectBtn.disabled = currentGraphMode !== 'collect';
        if (submitSourceBtn) submitSourceBtn.disabled = currentGraphMode !== 'collect';
      }

      async function submitStructuredSearchTasks(flowType = 'collect') {
        if (currentGraphMode !== 'collect') {
          showMessage('error', '请先切换到采集模式，再提交结构化搜索任务。');
          return;
        }
        if (!lastSelectionExportPayload) lastSelectionExportPayload = buildSelectionExportPayload();
        if (!Array.isArray(lastSelectionExportPayload.selected_nodes) || !lastSelectionExportPayload.selected_nodes.length) {
          showMessage('error', '当前未选中可提交节点。');
          return;
        }
        const requestPayload = {
          selected_nodes: lastSelectionExportPayload.selected_nodes,
          dashboard: lastSelectionExportPayload.dashboard,
          llm_assist: !!lastSelectionExportPayload.llm_assist,
          flow_type: flowType,
          intent_mode: 'keyword_llm',
        };
        renderStructuredTaskResult({ status: 'submitting', flow_type: flowType, summary: { accepted: '-', queued: '-', failed: '-' }, batches: [] });
        try {
          const result = await window.MarketApp.fetchJSON('/api/v1/ingest/graph/structured-search', {
            method: 'POST',
            body: requestPayload,
          });
          renderStructuredTaskResult({ ...(result || {}), flow_type: result?.flow_type || flowType });
          showMessage('info', `结构化搜索任务已提交（${lastSelectionExportPayload.selected_nodes.length} 个节点，flow_type=${flowType}）。`);
        } catch (err) {
          renderStructuredTaskResult({ status: 'error', flow_type: flowType, summary: { failed: 1 }, batches: [] });
          showMessage('error', `提交结构化搜索任务失败: ${err?.message || '未知错误'}`);
        }
      }

      function legendGroupForType(type) {
        const t = String(type || '');
        if (t.startsWith('Company')) return 'company';
        if (t.startsWith('Product')) return 'product';
        if (t.startsWith('Operation')) return 'operation';
        if (['MarketData', 'State', 'Segment', 'Entity', 'TopicTag', 'Policy', 'Post', 'Keyword', 'Topic', 'SentimentTag', 'User', 'Subreddit'].includes(t)) return 'base';
        return 'other';
      }

      function humanizeTypeName(type) {
        return String(type || '')
          .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
          .replace(/_/g, ' ')
          .trim();
      }

      function legendTypeLabel(type) {
        if (legendLang === 'en') return humanizeTypeName(type);
        return graphConfig.nodeLabels?.[type] || LEGEND_ZH_LABELS_FALLBACK[type] || type;
      }

      function legendGroupLabel(groupKey) {
        const zh = ({ base: '基础图例', company: '公司图例', product: '商品图例', operation: '电商/经营图例', other: '其他图例' })[groupKey] || '其他图例';
        const en = ({ base: 'Base Legend', company: 'Company Legend', product: 'Product Legend', operation: 'Operation Legend', other: 'Other Legend' })[groupKey] || 'Other Legend';
        return legendLang === 'en' ? en : zh;
      }

      function buildLegendHtml(nodeTypes) {
        const grouped = new Map();
        (nodeTypes || []).forEach((t) => {
          const g = legendGroupForType(t);
          if (!grouped.has(g)) grouped.set(g, []);
          grouped.get(g).push(t);
        });
        const order = ['base', 'company', 'product', 'operation', 'other'];
        return order.filter(g => grouped.has(g)).map((g) => {
          const types = grouped.get(g) || [];
          const allHidden = types.length > 0 && types.every(t => hiddenNodeTypes.has(t));
          const collapsed = collapsedLegendGroups.has(g);
          const itemsHtml = types.map(t => {
            const color = graphConfig.nodeColors?.[t] || '#94a3b8';
            const label = legendTypeLabel(t);
            const symbol = String(graphConfig.nodeSymbols?.[t] || 'circle');
            const symbolClass = ['circle', 'emptyCircle', 'roundRect', 'emptyRoundRect', 'rect', 'emptyRect', 'diamond', 'emptyDiamond', 'triangle', 'emptyTriangle', 'pin', 'emptyPin', 'arrow', 'emptyArrow'].includes(symbol) ? symbol : 'circle';
            const hiddenCls = hiddenNodeTypes.has(t) ? ' is-hidden' : '';
            const title = legendLang === 'en' ? 'Click to toggle visible/hidden' : '点击切换显示/隐藏';
            const text = legendLang === 'en' ? `${label} (${t})` : `${t} ${label}`;
            return `<div class="legend-item${hiddenCls}" data-legend-type="${t}" title="${title}"><span class="legend-symbol" style="color:${color};"><span class="legend-symbol-shape ${symbolClass}"></span></span>${text}</div>`;
          }).join('');
          return `<div class="legend-group${collapsed ? ' collapsed' : ''}" data-legend-group="${g}">
            <div class="legend-group-header">
              <div class="legend-group-title" data-legend-group-collapse="${g}"><span>${collapsed ? '▸' : '▾'}</span><span>${legendGroupLabel(g)}</span><span style="font-size:12px;color:#64748b;">(${types.length})</span></div>
              <div class="legend-group-actions">
                <button type="button" class="legend-group-btn ${allHidden ? 'is-off' : ''}" data-legend-group-toggle="${g}">${legendLang === 'en' ? (allHidden ? 'Show All' : 'Hide All') : (allHidden ? '显示全部' : '隐藏全部')}</button>
              </div>
            </div>
            <div class="legend-group-items">${itemsHtml}</div>
          </div>`;
        }).join('');
      }

      function renderLegend(nodeTypes) {
        const legendEl = document.getElementById('legend');
        const fullscreenLegendEl = document.getElementById('fullscreen-legend');
        const html = buildLegendHtml(nodeTypes);
        if (legendEl) legendEl.innerHTML = html;
        if (fullscreenLegendEl) fullscreenLegendEl.innerHTML = html;
        [legendEl, fullscreenLegendEl].forEach((root) => {
          if (!root) return;
          root.onclick = (e) => {
            const typeItem = e.target.closest('[data-legend-type]');
            if (typeItem) {
              const t = typeItem.getAttribute('data-legend-type');
              if (!t) return;
              if (hiddenNodeTypes.has(t)) hiddenNodeTypes.delete(t); else hiddenNodeTypes.add(t);
              renderLegend(graphConfig.nodeTypes || []);
              if (latestGraphData) updateHiddenTypeVisibility();
              return;
            }
            const groupToggle = e.target.closest('[data-legend-group-toggle]');
            if (groupToggle) {
              const g = groupToggle.getAttribute('data-legend-group-toggle');
              const groupTypes = (graphConfig.nodeTypes || []).filter(t => legendGroupForType(t) === g);
              const allHidden = groupTypes.length > 0 && groupTypes.every(t => hiddenNodeTypes.has(t));
              groupTypes.forEach(t => { if (allHidden) hiddenNodeTypes.delete(t); else hiddenNodeTypes.add(t); });
              renderLegend(graphConfig.nodeTypes || []);
              if (latestGraphData) updateHiddenTypeVisibility();
              return;
            }
            const groupCollapse = e.target.closest('[data-legend-group-collapse]');
            if (groupCollapse) {
              const g = groupCollapse.getAttribute('data-legend-group-collapse');
              if (!g) return;
              const willExpand = collapsedLegendGroups.has(g);
              // Accordion mode: only one group expanded at a time.
              collapsedLegendGroups.clear();
              if (!willExpand) {
                // clicking expanded one -> collapse all
                collapsedLegendGroups.add('base');
                collapsedLegendGroups.add('company');
                collapsedLegendGroups.add('product');
                collapsedLegendGroups.add('operation');
                collapsedLegendGroups.add('other');
              } else {
                ['base', 'company', 'product', 'operation', 'other'].forEach(key => {
                  if (key !== g) collapsedLegendGroups.add(key);
                });
              }
              renderLegend(graphConfig.nodeTypes || []);
            }
          };
        });
      }

      function filterGraphByHiddenTypes(data) {
        const nodes = (data?.nodes || []).filter(n => !hiddenNodeTypes.has(String(n?.type || '')));
        const keep = new Set(nodes.map(n => `${n.type}:${n.id}`));
        const edges = (data?.edges || []).filter(e => {
          const fk = e?.from ? `${e.from.type}:${e.from.id}` : '';
          const tk = e?.to ? `${e.to.type}:${e.to.id}` : '';
          return keep.has(fk) && keep.has(tk);
        });
        return { ...(data || {}), nodes, edges };
      }

      function cacheNodeLayoutFromChart(chart) {
        if (!chart) return;
        const opt = chart.getOption?.();
        const series = opt?.series?.[0];
        if (!series || !Array.isArray(series.data)) return;
        for (const n of series.data) {
          const v = n?.value || {};
          if (!v?.type || v?.id == null) continue;
          if (Number.isFinite(n?.x) && Number.isFinite(n?.y)) {
            nodeLayoutCache.set(`${v.type}:${v.id}`, { x: n.x, y: n.y });
          }
        }
      }

      function buildEchartsGraphData(data) {
        const filtered = filterGraphByHiddenTypes(data);
        currentFilteredGraphData = filtered;
        const nodes = filtered.nodes || [];
        const edges = filtered.edges || [];
        adjacencyIndex = buildSelectionIndex(filtered);
        const visibleKeys = new Set(nodes.map((n) => keyOfNode(n)));
        Array.from(selectedNodeKeys).forEach((k) => {
          if (!visibleKeys.has(k)) selectedNodeKeys.delete(k);
        });
        const config = {
          nodeColors: graphConfig.nodeColors,
          nodeSymbols: graphConfig.nodeSymbols,
          nodeSizeRules: graphConfig.nodeSizeRules,
          showLabels
        };
        const transformed = GV.transformGraphData(nodes, edges, config);
        transformed.nodes = (transformed.nodes || []).map((n) => {
          const v = n?.value || {};
          const key = `${v.type}:${v.id}`;
          const pos = nodeLayoutCache.get(`${v.type}:${v.id}`);
          const scaledSize = Math.max(6, Math.round(Number(n?.symbolSize || 0) * nodeScaleFactor));
          const shouldShowLabel = !!showLabels && scaledSize >= 22;
          const labelFontSize = Math.max(10, Math.min(18, Math.round(scaledSize * 0.42)));
          const isSelected = selectedNodeKeys.has(key);
          const dimmed = !!selectionEnabled && selectedNodeKeys.size > 0 && !isSelected;
          const scaled = {
            ...n,
            symbolSize: scaledSize,
            itemStyle: {
              ...(n.itemStyle || {}),
              opacity: dimmed ? 0.18 : 1,
              borderWidth: isSelected ? 3 : 0,
              borderColor: isSelected ? '#0f172a' : 'transparent',
              shadowBlur: isSelected ? 16 : 0,
              shadowColor: isSelected ? 'rgba(15,23,42,0.35)' : 'transparent'
            },
            label: {
              ...(n.label || {}),
              show: shouldShowLabel,
              fontSize: labelFontSize,
              opacity: dimmed ? 0.3 : 1,
              backgroundColor: shouldShowLabel ? 'rgba(255,255,255,0.85)' : 'transparent',
              padding: shouldShowLabel ? [2, Math.max(4, Math.round(labelFontSize * 0.35))] : 0,
            },
            emphasis: {
              ...(n.emphasis || {}),
              label: {
                ...((n.emphasis || {}).label || {}),
                show: true,
                fontSize: Math.max(labelFontSize, 12),
                backgroundColor: 'rgba(255,255,255,0.92)',
                padding: [2, Math.max(4, Math.round(labelFontSize * 0.35))],
              }
            }
          };
          return pos ? { ...scaled, x: pos.x, y: pos.y } : scaled;
        });
        transformed.edges = (transformed.edges || []).map((e) => {
          const src = String(e?.source || '');
          const tgt = String(e?.target || '');
          const active = selectedNodeKeys.has(src) && selectedNodeKeys.has(tgt);
          const dimmed = !!selectionEnabled && selectedNodeKeys.size > 0 && !active;
          return {
            ...e,
            lineStyle: {
              ...(e.lineStyle || {}),
              opacity: dimmed ? 0.08 : 0.9,
              width: dimmed ? 0.5 : Math.max(1.2, Number(e?.lineStyle?.width || 1))
            }
          };
        });
        updateSelectionUiState();
        return { filtered, transformed, config };
      }

      function updateHiddenTypeVisibility() {
        if (!latestGraphData) return;
        cacheNodeLayoutFromChart(graphChart);
        cacheNodeLayoutFromChart(fullscreenChart);
        const { filtered, transformed } = buildEchartsGraphData(latestGraphData);
        const applyToChart = (chart) => {
          if (!chart) return;
          chart.setOption({
            series: [{
              type: 'graph',
              layout: 'force',
              data: transformed.nodes || [],
              links: transformed.edges || [],
              force: {
                repulsion: currentRepulsion,
                gravity: 0.08,
                edgeLength: [80, 180],
                friction: 0.2
              }
            }]
          }, false, false);
        };
        applyToChart(graphChart);
        applyToChart(fullscreenChart);
        updateStats(filtered);
      }

      function renderStatsSkeleton(nodeTypes) {
        const statsEl = document.getElementById('stats');
        if (!statsEl) return;
        const lbl = (t) => legendLang === 'en' ? humanizeTypeName(t) : (graphConfig.nodeLabels?.[t] || LEGEND_ZH_LABELS_FALLBACK[t] || t);
        const nodeTitle = legendLang === 'en' ? 'Nodes' : '节点总数';
        const edgeTitle = legendLang === 'en' ? 'Edges' : '边总数';
        const countSuffix = legendLang === 'en' ? ' Count' : '数量';
        statsEl.innerHTML = `<div class="stat-card"><h3>${nodeTitle}</h3><div class="value" id="stat-nodes">-</div></div><div class="stat-card"><h3>${edgeTitle}</h3><div class="value" id="stat-edges">-</div></div>` +
          (nodeTypes || []).map(t => `<div class="stat-card"><h3>${lbl(t)}${countSuffix}</h3><div class="value" id="stat-${t}">-</div></div>`).join('');
      }

      function adaptNodePresentationToData(nodes) {
        const actualTypes = Array.from(new Set((nodes || []).map(n => n?.type).filter(Boolean)));
        const configuredTypes = Array.isArray(graphConfig.nodeTypes) ? graphConfig.nodeTypes : [];
        const orderedTypes = configuredTypes.filter(t => actualTypes.includes(t));
        actualTypes.forEach(t => { if (!orderedTypes.includes(t)) orderedTypes.push(t); });

        graphConfig.nodeTypes = orderedTypes;
        graphConfig.nodeColors = graphConfig.nodeColors || {};
        graphConfig.nodeSymbols = graphConfig.nodeSymbols || {};
        graphConfig.nodeSizeRules = graphConfig.nodeSizeRules || {};
        orderedTypes.forEach((t, idx) => {
          if (!graphConfig.nodeColors[t]) graphConfig.nodeColors[t] = FALLBACK_TYPE_COLORS[idx % FALLBACK_TYPE_COLORS.length];
          if (!graphConfig.nodeSymbols[t]) graphConfig.nodeSymbols[t] = FALLBACK_TYPE_SYMBOLS[idx % FALLBACK_TYPE_SYMBOLS.length];
          if (!graphConfig.nodeSizeRules[t]) graphConfig.nodeSizeRules[t] = { base: 18, max: 38 };
        });

        renderStatsSkeleton(orderedTypes);
        renderLegend(orderedTypes);
      }

      function escapeHtml(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function getGraphContextHtml(nodeData) {
        try {
          const data = latestGraphData;
          if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) return '';
          const nodeKey = `${nodeData.type}:${nodeData.id}`;
          const nodeByKey = new Map((data.nodes || []).map(n => [`${n.type}:${n.id}`, n]));
          const incident = [];
          const neighborTypeCounts = new Map();
          const predicates = new Map();
          const relatedDocs = new Map();

          for (const edge of (data.edges || [])) {
            const fromKey = edge?.from ? `${edge.from.type}:${edge.from.id}` : '';
            const toKey = edge?.to ? `${edge.to.type}:${edge.to.id}` : '';
            if (fromKey !== nodeKey && toKey !== nodeKey) continue;
            incident.push(edge);
            const other = fromKey === nodeKey ? edge.to : edge.from;
            if (other?.type) neighborTypeCounts.set(other.type, (neighborTypeCounts.get(other.type) || 0) + 1);
            const pred = String(edge?.predicate || edge?.type || '').trim();
            if (pred) predicates.set(pred, (predicates.get(pred) || 0) + 1);
            if (other?.type === 'MarketData' && other?.id != null) {
              const nk = `${other.type}:${other.id}`;
              const nn = nodeByKey.get(nk) || other;
              const label = nn.title || nn.name || nn.text || `文档 ${other.id}`;
              relatedDocs.set(String(other.id), { id: other.id, label });
            }
          }

          const degree = incident.length;
          const neighborItems = Array.from(neighborTypeCounts.entries())
            .sort((a, b) => b[1] - a[1])
            .map(([t, c]) => `${t}: ${c}`);
          const predItems = Array.from(predicates.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 8)
            .map(([p, c]) => `${p} (${c})`);
          const docs = Array.from(relatedDocs.values()).slice(0, 8);
          if (window.UICards?.renderSectionCard) {
            return window.UICards.renderSectionCard({
              title: '图谱上下文',
              compact: true,
              style: 'margin-bottom:12px;',
              metrics: [
                { label: '连接数（Degree）', value: degree },
                { label: '关联节点类型数', value: neighborTypeCounts.size },
                { label: '关联文档数（MarketData）', value: relatedDocs.size },
              ],
              chipGroups: [
                { label: '相邻节点类型分布', items: neighborItems },
                { label: '关键关系/谓词', items: predItems },
              ],
              lists: [
                {
                  label: '关联文档（Top 8）',
                  emptyText: '无直接关联文档节点',
                  items: docs.map(d => ({ html: `<a class="link" href="#" data-doc-id=\"${window.UICards.esc(String(d.id))}\">${window.UICards.esc(String(d.label))}</a>` })),
                }
              ]
            });
          }
          const docsHtml = docs.length ? docs.map(d => `<li><a class="link" href="#" data-doc-id=\"${escapeHtml(String(d.id))}\">${escapeHtml(String(d.label))}</a></li>`).join('') : '<li style="color:#64748b;">无直接关联文档节点</li>';
          return `<div class="extracted-card" style="margin-bottom:12px;"><div style="font-weight:700;color:#0f172a;margin-bottom:10px;">图谱上下文</div><div class="info-grid"><div class="info-item"><label>连接数（Degree）</label><div class="value">${degree}</div></div><div class="info-item"><label>关联节点类型数</label><div class="value">${neighborTypeCounts.size}</div></div><div class="info-item"><label>关联文档数（MarketData）</label><div class="value">${relatedDocs.size}</div></div></div><div style="margin-top:12px;"><label style="display:block;color:#64748b;font-size:12px;margin-bottom:6px;">相邻节点类型分布</label><div style="display:flex;flex-wrap:wrap;gap:6px;">${neighborItems.map(x=>`<span class=\"chip\">${escapeHtml(x)}</span>`).join('') || '<span style=\"color:#64748b;\">无</span>'}</div></div><div style=\"margin-top:12px;\"><label style=\"display:block;color:#64748b;font-size:12px;margin-bottom:6px;\">关键关系/谓词</label><div style=\"display:flex;flex-wrap:wrap;gap:6px;\">${predItems.map(x=>`<span class=\"chip\">${escapeHtml(x)}</span>`).join('') || '<span style=\"color:#64748b;\">无</span>'}</div></div><div style=\"margin-top:12px;\"><label style=\"display:block;color:#64748b;font-size:12px;margin-bottom:6px;\">关联文档（Top 8）</label><ul style=\"margin:0;padding-left:18px;\">${docsHtml}</ul></div></div>`;
        } catch (e) {
          console.warn('build graph context failed', e);
          return '';
        }
      }

      async function showNodeDetail(nodeData, isEdge) {
        detailsTitle.textContent = isEdge ? `连接详情 - ${nodeData.type || 'Edge'}` : `节点详情 - ${nodeData.title || nodeData.name || nodeData.text || nodeData.canonical_name || nodeData.id}`;
        detailsContent.innerHTML = '<div style="text-align:center;padding:24px;color:#64748b;">加载中...</div>';
        detailsPanel.classList.add('active');

        if (isEdge) {
          detailsContent.innerHTML = `<div class="extracted-card"><div class="info-grid">
            <div class="info-item"><label>关系类型</label><div class="value">${escapeHtml(nodeData.type || '-')}</div></div>
            ${nodeData.predicate ? `<div class="info-item"><label>谓词</label><div class="value">${escapeHtml(nodeData.predicate)}</div></div>` : ''}
            ${nodeData.confidence != null ? `<div class="info-item"><label>置信度</label><div class="value">${(nodeData.confidence * 100).toFixed(1)}%</div></div>` : ''}
          </div></div>`;
          return;
        }

        const docTypes = ['Post', 'MarketData', 'Policy'];
        const graphContextHtml = getGraphContextHtml(nodeData);
        if (docTypes.includes(nodeData.type) && nodeData.id && window.MarketApp?.fetchJSON) {
          try {
            const doc = await window.MarketApp.fetchJSON(`/api/v1/admin/documents/${nodeData.id}`);
            let extractedData = doc?.extracted_data;
            if (typeof extractedData === 'string') {
              try { extractedData = JSON.parse(extractedData); } catch (e) { extractedData = {}; }
            }
            const extracted = extractedData || {};
            const cardLabels = { nodeLabels: graphConfig.nodeLabels || {}, fieldLabels: graphConfig.fieldLabels || {} };
            const cardHtml = window.renderGraphExtractedCard ? window.renderGraphExtractedCard(extracted, escapeHtml, cardLabels) : '';
            const textOrContent = (extracted.text || doc?.content || '').substring(0, 5000);
            const bodyHtml = `
              ${graphContextHtml}
              <div><strong>标题:</strong> ${escapeHtml(doc?.title || '(无)')}</div>
              ${doc?.uri ? `<div style="margin-top:12px;"><strong>URL:</strong> <a href="${doc.uri}" target="_blank" class="link">${escapeHtml(doc.uri)}</a></div>` : ''}
              ${cardHtml}
              ${textOrContent ? `<div style="margin-top:16px;"><strong>内容:</strong><div class="content-preview">${escapeHtml(textOrContent)}${(extracted.text || doc?.content || '').length > 5000 ? '...' : ''}</div></div>` : ''}
              <div style="margin-top:16px;padding-top:16px;border-top:1px solid #e5e7eb;font-size:12px;color:#6b7280;">
                <div><strong>创建时间:</strong> ${doc?.created_at ? new Date(doc.created_at).toLocaleString('zh-CN') : '-'}</div>
                <div style="margin-top:8px;"><strong>更新时间:</strong> ${doc?.updated_at ? new Date(doc.updated_at).toLocaleString('zh-CN') : '-'}</div>
              </div>
            `;
            detailsContent.innerHTML = bodyHtml;
            window.enhanceExtractedCardTabs?.(detailsContent);
            detailsContent.querySelectorAll('[data-doc-id]').forEach(el => {
              el.addEventListener('click', async (evt) => {
                evt.preventDefault();
                const id = el.getAttribute('data-doc-id');
                if (!id) return;
                await showNodeDetail({ type: 'MarketData', id: Number(id) }, false);
              });
            });
          } catch (err) {
            console.error('加载文档详情失败:', err);
            detailsContent.innerHTML = `<div class="error">加载失败: ${escapeHtml(err.message)}</div>`;
          }
        } else {
          const items = [];
          Object.keys(nodeData).filter(k => !['value', 'symbol', 'symbolSize', 'itemStyle', 'label', 'emphasis'].includes(k)).forEach(k => {
            const v = nodeData[k];
            if (v != null && typeof v !== 'object') items.push(`<div class="info-item"><label>${escapeHtml(k)}</label><div class="value">${escapeHtml(String(v))}</div></div>`);
            else if (v != null && typeof v === 'object' && !Array.isArray(v)) items.push(`<div class="info-item"><label>${escapeHtml(k)}</label><div class="value">${escapeHtml(JSON.stringify(v))}</div></div>`);
          });
          detailsContent.innerHTML = `${graphContextHtml}<div class="extracted-card"><div class="info-grid">${items.join('')}</div></div>`;
          window.enhanceExtractedCardTabs?.(detailsContent);
          detailsContent.querySelectorAll('[data-doc-id]').forEach(el => {
            el.addEventListener('click', async (evt) => {
              evt.preventDefault();
              const id = el.getAttribute('data-doc-id');
              if (!id) return;
              await showNodeDetail({ type: 'MarketData', id: Number(id) }, false);
            });
          });
        }
      }

      function attachControlPanel(container) {
        if (!graphControlPanel || !container) return;
        if (!container.contains(graphControlPanel)) container.insertBefore(graphControlPanel, container.firstChild);
      }

      async function loadGraphDocTypeHint() {
        const hintEl = document.getElementById('graph-doc-type-hint');
        const structureEl = document.getElementById('graph-structure-hint');
        const statsEl = document.getElementById('stats');
        if (!hintEl || !structureEl) return;
        try {
          const projectKey = window.MarketApp?.getProjectKey?.() || '';
          const query = projectKey ? `?project_key=${encodeURIComponent(projectKey)}` : '';
          const data = await window.MarketApp.fetchJSON(`/api/v1/project-customization/graph-config${query}`);
          const graphDocTypes = data?.graph_doc_types || {};
          const labels = data?.graph_type_labels || {};
          const graphNodeTypes = data?.graph_node_types || {};
          const graphNodeLabels = data?.graph_node_labels || {};
          const graphFieldLabels = data?.graph_field_labels || {};
          const graphEdgeTypes = data?.graph_edge_types || {};
          const relationLabels = data?.graph_relation_labels || {};
          const keys = GV.GRAPH_CONFIG_KEYS[graphType];
          const docTypes = Array.isArray(graphDocTypes[keys.docTypes]) ? graphDocTypes[keys.docTypes] : (graphType === 'policy' ? ['policy', 'policy_regulation'] : graphType === 'social' ? ['social_sentiment', 'social_feed'] : ['market_info', 'market']);
          const nodeTypes = Array.isArray(graphNodeTypes[keys.nodeTypes]) ? graphNodeTypes[keys.nodeTypes] : (graphType === 'policy' ? ['Policy', 'State', 'PolicyType', 'KeyPoint', 'Entity'] : graphType === 'social' ? ['Post', 'Keyword', 'Entity', 'Topic', 'SentimentTag', 'User', 'Subreddit'] : (graphType === 'market_deep_entities' ? ['MarketData', 'State', 'Segment', 'Entity', 'CompanyEntity', 'ProductEntity', 'OperationEntity', 'TopicTag'] : (graphType === 'company' ? ['MarketData', 'CompanyEntity', 'TopicTag'] : (graphType === 'product' ? ['MarketData', 'ProductEntity', 'TopicTag'] : (graphType === 'operation' ? ['MarketData', 'OperationEntity', 'TopicTag'] : ['MarketData', 'State', 'Segment', 'Entity'])))));
          const edgeTypes = Array.isArray(graphEdgeTypes[keys.edgeTypes]) ? graphEdgeTypes[keys.edgeTypes] : [];
          const typeLabel = graphType === 'company'
            ? '公司图谱'
            : graphType === 'product'
              ? '商品图谱'
              : graphType === 'operation'
                ? '电商/经营图谱'
                : graphType === 'market_deep_entities'
                  ? '市场实体加细图'
                  : (labels[keys.label] || (graphType === 'policy' ? '政策图谱' : graphType === 'social' ? '社媒图谱' : '市场图谱'));

          graphConfig = {
            nodeTypes,
            nodeLabels: graphNodeLabels,
            fieldLabels: graphFieldLabels,
            nodeColors: { ...GV.NODE_COLORS_BY_TYPE[graphType] },
            nodeSymbols: { ...GV.NODE_SYMBOLS_BY_TYPE[graphType] },
            nodeSizeRules: graphType === 'policy' ? { Policy: { base: 18, max: 52 }, State: { base: 16, max: 48 }, PolicyType: { base: 15, max: 42 }, KeyPoint: { base: 12, max: 36 }, Entity: { base: 14, max: 40 } } : {}
          };
          Object.keys(graphConfig.nodeSizeRules).length === 0 && nodeTypes.forEach(t => { graphConfig.nodeSizeRules[t] = { base: 18, max: 38 }; });

          const titleEl = document.getElementById('graph-page-title');
          if (titleEl) titleEl.textContent = typeLabel;
          document.getElementById('graph-title').textContent = typeLabel;
          document.getElementById('fullscreen-title').textContent = typeLabel + '（全屏）';
          hintEl.textContent = `${typeLabel}数据类型: ${docTypes.join(', ')}`;
          const edgeLabels = edgeTypes.map(e => relationLabels[e] ? `${e}(${relationLabels[e]})` : e);
          structureEl.textContent = `节点类型: ${nodeTypes.join(', ')}；关系类型: ${edgeLabels.join(', ')}`;

          if (statsEl) renderStatsSkeleton(nodeTypes);
          renderLegend(nodeTypes);
        } catch (e) {
          hintEl.textContent = '加载配置失败';
        }
      }

      async function loadGraph() {
        showMessage('info', '正在加载图谱...');
        detailsPanel.classList.remove('active');
        latestGraphData = null;
        clearSelection({ rerender: false });
        const chartEl = document.getElementById('graph-chart');
        if (graphChart) {
          try { graphChart.dispose(); } catch (e) { console.warn('dispose graphChart failed before reload', e); }
          graphChart = null;
        }
        chartEl.innerHTML = '<div class="loading"><span class="spinner"></span>加载中...</div>';

        try {
          const params = GV.buildParams(graphType, getFilterValues());
          const apiPath = GV.API_PATHS[graphType];
          const data = await window.MarketApp.fetchJSON(`${apiPath}?${params.toString()}`, { cache: 'no-store' });
          const preparedData = data;
          latestGraphData = preparedData;
          const nodes = preparedData.nodes || [];
          const edges = preparedData.edges || [];
          adaptNodePresentationToData(nodes);
          if (graphChart) {
            try { graphChart.dispose(); } catch (e) { console.warn('dispose graphChart failed before render', e); }
            graphChart = null;
          }
          chartEl.innerHTML = '';
          graphChart = echarts.init(chartEl);
          renderGraph({ nodes, edges });
          updateStats(filterGraphByHiddenTypes({ nodes, edges }));
          if (nodes.length === 0) {
            if (graphType === 'company' || graphType === 'product' || graphType === 'operation') {
              const topicLabel = graphType === 'company' ? '公司' : (graphType === 'product' ? '商品' : '电商/经营');
              showMessage('info', `未查询到 ${topicLabel}专题图谱节点。请先在对应专题页面运行“${topicLabel}专题析取（补齐/强制）”。`);
            } else {
              showMessage('info', '未查询到符合条件的数据。');
            }
          }
          else showMessage('', '');
        } catch (err) {
          console.error('加载图谱失败', err);
          showMessage('error', `加载图谱失败: ${err.message}`);
          if (graphChart) {
            try { graphChart.dispose(); } catch (e) { console.warn('dispose graphChart failed in error path', e); }
            graphChart = null;
          }
          chartEl.innerHTML = '';
          graphChart = echarts.init(chartEl);
          renderGraph({ nodes: [], edges: [] });
          adaptNodePresentationToData([]);
          updateStats(filterGraphByHiddenTypes({ nodes: [], edges: [] }));
        }
      }

      function updateStats(data) {
        const nodes = data.nodes || [];
        const edges = data.edges || [];
        const el = id => document.getElementById(id);
        if (el('stat-nodes')) el('stat-nodes').textContent = nodes.length;
        if (el('stat-edges')) el('stat-edges').textContent = edges.length;
        (graphConfig.nodeTypes || []).forEach(t => {
          const e = el('stat-' + t);
          if (e) e.textContent = nodes.filter(n => n.type === t).length || 0;
        });
      }

      function updateRepulsion() {
        if (!graphChart || !latestGraphData) return;
        graphChart.setOption({
          series: [{
            force: {
              repulsion: currentRepulsion,
              gravity: 0.08,
              edgeLength: [80, 180],
              friction: 0.2
            }
          }]
        });
        if (isFullscreen && fullscreenChart) {
          fullscreenChart.setOption({
            series: [{
              force: {
                repulsion: currentRepulsion,
                gravity: 0.08,
                edgeLength: [80, 180],
                friction: 0.2
              }
            }]
          });
        }
      }

      function updateLabelVisibility() {
        const applyToChart = (chart) => {
          if (!chart) return;
          const opt = chart.getOption?.();
          const series = opt?.series?.[0];
          if (!series || !Array.isArray(series.data)) return;
          const nextData = series.data.map((n) => {
            const size = Number(n?.symbolSize || 0);
            const shouldShowLabel = !!showLabels && size >= 22;
            const labelFontSize = Math.max(10, Math.min(18, Math.round(size * 0.42)));
            return {
              ...n,
              label: {
                ...(n.label || {}),
                show: shouldShowLabel,
                fontSize: labelFontSize,
                backgroundColor: shouldShowLabel ? 'rgba(255,255,255,0.85)' : 'transparent',
                padding: shouldShowLabel ? [2, Math.max(4, Math.round(labelFontSize * 0.35))] : 0,
              },
              emphasis: {
                ...(n.emphasis || {}),
                label: {
                  ...((n.emphasis || {}).label || {}),
                  show: true,
                  fontSize: Math.max(labelFontSize, 12),
                }
              }
            };
          });
          chart.setOption({ series: [{ data: nextData }] }, false, false);
        };
        applyToChart(graphChart);
        applyToChart(fullscreenChart);
      }

      function updateNodeScaleVisibility() {
        if (!latestGraphData) return;
        cacheNodeLayoutFromChart(graphChart);
        cacheNodeLayoutFromChart(fullscreenChart);
        const { filtered, transformed } = buildEchartsGraphData(latestGraphData);
        const applyToChart = (chart) => {
          if (!chart) return;
          chart.setOption({
            series: [{
              type: 'graph',
              layout: 'force',
              data: transformed.nodes || [],
              links: transformed.edges || [],
              force: {
                repulsion: currentRepulsion,
                gravity: 0.08,
                edgeLength: [80, 180],
                friction: 0.2
              }
            }]
          }, false, false);
        };
        applyToChart(graphChart);
        applyToChart(fullscreenChart);
        updateStats(filtered);
      }

      function handleNodeSingleSelect(nodeData) {
        if (!nodeData || nodeData.type == null || nodeData.id == null) return;
        const key = `${nodeData.type}:${nodeData.id}`;
        if (selectedNodeKeys.has(key)) selectedNodeKeys.delete(key);
        else selectedNodeKeys.add(key);
        lastSelectionExportPayload = null;
        updateHiddenTypeVisibility();
      }

      function handleNodeDoubleSelect(nodeData) {
        if (!nodeData || nodeData.type == null || nodeData.id == null) return;
        const key = `${nodeData.type}:${nodeData.id}`;
        selectedNodeKeys.add(key);
        const neighbors = adjacencyIndex.get(key) || new Set();
        neighbors.forEach((n) => selectedNodeKeys.add(n));
        lastSelectionExportPayload = null;
        updateHiddenTypeVisibility();
      }

      function renderGraph(data) {
        if (!graphChart) return;
        const { transformed, config } = buildEchartsGraphData(data);
        const echartsNodes = transformed.nodes || [];
        const echartsEdges = transformed.edges || [];

        const option = {
          tooltip: {
            formatter: params => GV.tooltipFormatter(params, config)
          },
          series: [{
            type: 'graph',
            layout: 'force',
            roam: true,
            data: echartsNodes,
            links: echartsEdges,
            force: {
              repulsion: currentRepulsion,
              gravity: 0.08,
              edgeLength: [80, 180],
              friction: 0.2
            },
            lineStyle: { opacity: 0.9, width: 1, color: '#cbd5e1' },
            emphasis: { focus: 'adjacency', lineStyle: { width: 2 } }
          }]
        };

        graphChart.setOption(option, true);
        graphChart.off('click');
        graphChart.off('dblclick');
        graphChart.on('click', params => {
          if (params.dataType === 'node') {
            const value = params.data.value || params.data || {};
            if (!selectionEnabled) {
              showNodeDetail(value, false);
              return;
            }
            if (nodeClickTimer) clearTimeout(nodeClickTimer);
            nodeClickTimer = setTimeout(() => {
              handleNodeSingleSelect(value);
              nodeClickTimer = null;
            }, 220);
          } else if (params.dataType === 'edge') {
            if (selectionEnabled) return;
            const value = params.data.value || params.data || {};
            showNodeDetail(value, true);
          }
        });
        graphChart.on('dblclick', params => {
          if (!selectionEnabled || params.dataType !== 'node') return;
          if (nodeClickTimer) {
            clearTimeout(nodeClickTimer);
            nodeClickTimer = null;
          }
          const value = params.data.value || params.data || {};
          handleNodeDoubleSelect(value);
        });

        if (isFullscreen && fullscreenChart && latestGraphData) renderFullscreenGraph();
      }

      function renderFullscreenGraph() {
        if (!fullscreenChart || !latestGraphData) return;
        const opt = graphChart.getOption();
        fullscreenChart.setOption(opt, true);
        fullscreenChart.off('click');
        fullscreenChart.off('dblclick');
        fullscreenChart.on('click', params => {
          if (params.dataType === 'node') {
            const value = params.data.value || params.data || {};
            if (!selectionEnabled) {
              showNodeDetail(value, false);
              return;
            }
            if (nodeClickTimer) clearTimeout(nodeClickTimer);
            nodeClickTimer = setTimeout(() => {
              handleNodeSingleSelect(value);
              nodeClickTimer = null;
            }, 220);
          } else if (params.dataType === 'edge') {
            if (selectionEnabled) return;
            const value = params.data.value || params.data || {};
            showNodeDetail(value, true);
          }
        });
        fullscreenChart.on('dblclick', params => {
          if (!selectionEnabled || params.dataType !== 'node') return;
          if (nodeClickTimer) {
            clearTimeout(nodeClickTimer);
            nodeClickTimer = null;
          }
          const value = params.data.value || params.data || {};
          handleNodeDoubleSelect(value);
        });
      }

      function toggleFullscreen(enable) {
        const fullscreenView = document.getElementById('graph-fullscreen-view');
        const originalChartEl = document.getElementById('graph-chart');
        const notifyAppShellFullscreen = (action) => {
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ type: 'fullscreen', action }, '*');
            }
          } catch (_) {}
        };
        if (enable && !isFullscreen) {
          attachControlPanel(fullscreenGraphContainer);
          if (originalChartEl) originalChartEl.style.display = 'none';
          fullscreenView.classList.add('active');
          isFullscreen = true;
          notifyAppShellFullscreen('enter');
          if (!fullscreenChart) fullscreenChart = echarts.init(document.getElementById('fullscreen-graph-chart'));
          renderFullscreenGraph();
          fullscreenChart.resize();
        } else if (!enable && isFullscreen) {
          fullscreenView.classList.remove('active');
          isFullscreen = false;
          notifyAppShellFullscreen('exit');
          if (fullscreenChart) { fullscreenChart.dispose(); fullscreenChart = null; }
          if (originalChartEl) originalChartEl.style.display = 'block';
          attachControlPanel(mainGraphContainer);
          graphChart && graphChart.resize();
        }
      }

      function resetFilters() {
        document.getElementById('filter-start').value = '';
        document.getElementById('filter-end').value = '';
        limitInput.value = 100;
        if (graphType === 'policy') {
          const stateEl = document.getElementById('filter-state');
          const typeEl = document.getElementById('filter-type');
          if (stateEl) stateEl.value = '';
          if (typeEl) typeEl.value = '';
        } else if (graphType === 'social') {
          const platformEl = document.getElementById('filter-platform');
          const topicEl = document.getElementById('filter-topic');
          if (platformEl) platformEl.value = '';
          if (topicEl) topicEl.value = '';
        } else if (graphType === 'market' || graphType === 'market_deep_entities' || graphType === 'company' || graphType === 'product' || graphType === 'operation') {
          const viewEl = document.getElementById('filter-market-view');
          if (viewEl) viewEl.value = graphType === 'market_deep_entities' ? 'market_deep_entities' : 'market';
          const stateEl = document.getElementById('filter-state');
          const gameEl = document.getElementById('filter-game');
          if (stateEl) stateEl.value = '';
          if (gameEl) gameEl.value = '';
        }
        if (repulsionSlider) repulsionSlider.value = '180';
        currentRepulsion = 180;
        if (repulsionValueEl) repulsionValueEl.textContent = '180';
        if (nodeScaleSlider) nodeScaleSlider.value = '100';
        nodeScaleFactor = 1;
        if (nodeScaleValueEl) nodeScaleValueEl.textContent = '100%';
        if (labelToggle) { labelToggle.checked = true; showLabels = true; }
        if (selectionToggle) { selectionToggle.checked = false; selectionEnabled = false; }
        const resetDashboard = [
          ['dashboard-language', 'en'],
          ['dashboard-provider', 'auto'],
          ['dashboard-max-items', '100'],
          ['dashboard-start-offset', ''],
          ['dashboard-days-back', '7'],
          ['dashboard-platforms', 'reddit'],
          ['dashboard-base-subreddits', ''],
        ];
        resetDashboard.forEach(([id, value]) => {
          const el = document.getElementById(id);
          if (el) el.value = value;
        });
        ['dashboard-enable-extraction', 'dashboard-async-mode', 'dashboard-llm-assist'].forEach((id) => {
          const el = document.getElementById(id);
          if (el) el.checked = true;
        });
        ['dashboard-enable-subreddit-discovery'].forEach((id) => {
          const el = document.getElementById(id);
          if (el) el.checked = false;
        });
        setGraphMode('browse');
        clearSelection({ rerender: false });
        loadGraph();
      }

      function init() {
        renderExtraFilters();
        window.addEventListener('resize', () => {
          graphChart && graphChart.resize();
          if (fullscreenChart) fullscreenChart.resize();
        });
        document.getElementById('apply-btn').addEventListener('click', () => doRefresh());
        document.getElementById('reset-btn').addEventListener('click', resetFilters);
        function doRefresh() {
          const viewEl = document.getElementById('filter-market-view');
          const selectedView = viewEl?.value || '';
          if ((graphType === 'market' || graphType === 'market_deep_entities') && selectedView && selectedView !== graphType) {
            const url = new URL(window.location.href);
            url.searchParams.set('type', selectedView);
            window.location.href = url.toString();
            return;
          }
          if (isFullscreen) toggleFullscreen(false);
          loadGraph();
        }
        const refreshBtn = document.getElementById('refresh-btn');
        if (refreshBtn) refreshBtn.addEventListener('click', (e) => { e.preventDefault(); doRefresh(); });
        document.getElementById('fullscreen-btn').addEventListener('click', () => toggleFullscreen(true));
        document.getElementById('exit-fullscreen-btn').addEventListener('click', () => toggleFullscreen(false));
        document.getElementById('details-close-btn').addEventListener('click', () => detailsPanel.classList.remove('active'));
        detailsPanel.addEventListener('click', (e) => { if (e.target === detailsPanel) detailsPanel.classList.remove('active'); });
        const fullscreenRefreshBtn = document.getElementById('fullscreen-refresh-btn');
        if (fullscreenRefreshBtn) fullscreenRefreshBtn.addEventListener('click', (e) => { e.preventDefault(); doRefresh(); });
        if (repulsionSlider) {
          repulsionSlider.addEventListener('input', e => {
            currentRepulsion = Number(e.target.value);
            if (repulsionValueEl) repulsionValueEl.textContent = String(currentRepulsion);
            updateRepulsion();
          });
          if (repulsionValueEl) repulsionValueEl.textContent = String(currentRepulsion);
        }
        if (nodeScaleSlider) {
          nodeScaleSlider.addEventListener('input', e => {
            const raw = Number(e.target.value || 100);
            nodeScaleFactor = raw / 100;
            if (nodeScaleValueEl) nodeScaleValueEl.textContent = `${raw}%`;
            updateNodeScaleVisibility();
          });
          if (nodeScaleValueEl) nodeScaleValueEl.textContent = `${Math.round(nodeScaleFactor * 100)}%`;
        }
        if (labelToggle) {
          labelToggle.addEventListener('change', () => {
            showLabels = labelToggle.checked;
            updateLabelVisibility();
          });
        }
        if (legendLangSelect) {
          legendLangSelect.value = legendLang;
          legendLangSelect.addEventListener('change', () => {
            legendLang = legendLangSelect.value === 'en' ? 'en' : 'zh';
            try { localStorage.setItem('graphLegendLang', legendLang); } catch (_) {}
            renderStatsSkeleton(graphConfig.nodeTypes || []);
            renderLegend(graphConfig.nodeTypes || []);
            if (latestGraphData) updateStats(filterGraphByHiddenTypes(latestGraphData));
          });
        }
        if (graphModeSelect) {
          graphModeSelect.addEventListener('change', () => {
            setGraphMode(graphModeSelect.value);
            lastSelectionExportPayload = null;
          });
        }
        [
          'dashboard-language',
          'dashboard-provider',
          'dashboard-max-items',
          'dashboard-start-offset',
          'dashboard-days-back',
          'dashboard-platforms',
          'dashboard-base-subreddits',
          'dashboard-enable-extraction',
          'dashboard-async-mode',
          'dashboard-enable-subreddit-discovery',
          'dashboard-llm-assist',
        ].forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          const eventName = el.type === 'checkbox' ? 'change' : 'input';
          el.addEventListener(eventName, () => {
            lastSelectionExportPayload = null;
            if (selectionExportPanel?.classList.contains('active')) {
              lastSelectionExportPayload = buildSelectionExportPayload();
              renderSelectionExportText(lastSelectionExportPayload);
              renderStructuredTaskPreview(lastSelectionExportPayload);
            }
          });
        });
        if (selectionToggle) {
          selectionToggle.addEventListener('change', () => {
            selectionEnabled = !!selectionToggle.checked;
            if (!selectionEnabled) clearSelection({ rerender: false });
            updateSelectionUiState();
            if (latestGraphData) updateHiddenTypeVisibility();
          });
        }
        if (selectionClearBtn) {
          selectionClearBtn.addEventListener('click', () => clearSelection());
        }
        if (selectionExportBtn) {
          selectionExportBtn.addEventListener('click', () => openSelectionExportPanel());
        }
        document.getElementById('selection-export-close-btn')?.addEventListener('click', closeSelectionExportPanel);
        document.getElementById('selection-copy-btn')?.addEventListener('click', () => copySelectionToClipboard());
        document.getElementById('selection-send-collect-btn')?.addEventListener('click', () => submitStructuredSearchTasks('collect'));
        document.getElementById('selection-send-source-btn')?.addEventListener('click', () => submitStructuredSearchTasks('source_collect'));
        selectionExportPanel?.addEventListener('click', (e) => { if (e.target === selectionExportPanel) closeSelectionExportPanel(); });
        setGraphMode(graphModeSelect?.value || 'browse');
        updateSelectionUiState();
        attachControlPanel(mainGraphContainer);
        loadGraphDocTypeHint().then(() => loadGraph());
      }

      document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>
