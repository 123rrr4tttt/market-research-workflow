<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ç¤¾äº¤åª’ä½“å¹³å°å›¾è°±å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="/static/js/app-shell.js"></script>
    <script src="/static/js/doc-card.js"></script>
    <style>
      * { box-sizing: border-box; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        margin: 0;
        padding: 24px;
        background: #f8fafc;
        color: #1e293b;
        line-height: 1.6;
      }
      body.in-iframe header {
        margin-bottom: 0;
        border-radius: 0;
      }
      .container {
        max-width: 100%;
        margin: 0 auto;
        width: 100%;
      }
      header {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 28px;
        color: #0f172a;
      }
      header p {
        margin: 0;
        color: #64748b;
      }
      .nav-links {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 16px;
      }
      .nav-links a {
        padding: 10px 20px;
        background: #2563eb;
        color: white;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 500;
        display: inline-block;
        transition: background 0.2s;
      }
      .nav-links a:hover {
        background: #1d4ed8;
      }
      .nav-links a.secondary {
        background: white;
        border: 1px solid #cbd5e1;
        color: #2563eb;
      }
      .nav-links a.secondary:hover {
        background: #f1f5f9;
      }
      .controls {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      .controls-row {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 16px;
      }
      .controls-row:last-child {
        margin-bottom: 0;
      }
      .controls label {
        font-weight: 500;
        color: #475569;
        white-space: nowrap;
      }
      .controls input, .controls select {
        padding: 8px 12px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
      }
      .controls input[type="date"] {
        min-width: 160px;
      }
      .controls button {
        padding: 8px 16px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      .controls button:hover {
        background: #1d4ed8;
      }
      .controls button:disabled {
        background: #94a3b8;
        cursor: not-allowed;
      }
      .graph-container {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      .graph-container h2 {
        margin: 0 0 16px 0;
        font-size: 18px;
        color: #0f172a;
        border-bottom: 2px solid #e2e8f0;
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .graph-header-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .fullscreen-btn {
        padding: 6px 12px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .fullscreen-btn:hover {
        background: #1d4ed8;
      }
      .fullscreen-btn:active {
        transform: scale(0.95);
      }
      #graph-chart {
        width: 100%;
        height: 700px;
        min-height: 500px;
      }
      /* å…¨å±è§†å›¾å®¹å™¨ */
      #graph-fullscreen-view {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        background: white;
        padding: 20px;
        box-sizing: border-box;
        overflow: auto;
      }
      #graph-fullscreen-view.active {
        display: block;
      }
      #graph-fullscreen-view .graph-container {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        border-radius: 0;
        box-shadow: none;
      }
      #graph-fullscreen-view #fullscreen-graph-chart {
        width: 100%;
        height: calc(100vh - 80px);
        min-height: 500px;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }
      .stat-card {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        border-left: 4px solid #2563eb;
      }
      .stat-card h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #64748b;
        font-weight: 500;
      }
      .stat-card .value {
        font-size: 32px;
        font-weight: 700;
        color: #0f172a;
      }
      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: #64748b;
      }
      .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #cbd5e1;
        border-top-color: #2563eb;
        border-radius: 50%;
        animation: spin 0.6s linear infinite;
        margin-right: 8px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .error {
        background: #fef2f2;
        border: 1px solid #fecaca;
        color: #991b1b;
        padding: 12px;
        border-radius: 8px;
        margin: 16px 0;
      }
      .info {
        background: #eff6ff;
        border: 1px solid #bfdbfe;
        color: #1e40af;
        padding: 12px;
        border-radius: 8px;
        margin: 16px 0;
      }
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        overflow: auto;
      }
      .modal-content {
        background-color: white;
        margin: 5% auto;
        padding: 24px;
        border-radius: 12px;
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 2px solid #e2e8f0;
      }
      .modal-header h2 {
        margin: 0;
        font-size: 24px;
        color: #0f172a;
      }
      .close {
        color: #94a3b8;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
      }
      .close:hover {
        color: #0f172a;
      }
      .post-detail-section {
        margin-bottom: 20px;
      }
      .post-detail-section h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #64748b;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .post-detail-section p {
        margin: 0;
        color: #1e293b;
        line-height: 1.6;
      }
      .post-detail-section a {
        color: #2563eb;
        text-decoration: none;
        word-break: break-all;
      }
      .post-detail-section a:hover {
        text-decoration: underline;
      }
      .tag-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .tag {
        background: #f1f5f9;
        color: #475569;
        padding: 4px 12px;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 500;
      }
      .tag.sentiment-positive {
        background: #dcfce7;
        color: #166534;
      }
      .tag.sentiment-negative {
        background: #fee2e2;
        color: #991b1b;
      }
      .tag.sentiment-neutral {
        background: #f1f5f9;
        color: #475569;
      }
      .content-preview {
        max-height: 400px;
        overflow-y: auto;
        padding: 12px;
        background: #f9fafb;
        border-radius: 6px;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
      }
      .extracted-card {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 16px;
        margin-top: 12px;
      }
      .extracted-section {
        margin-bottom: 20px;
      }
      .extracted-section:last-child {
        margin-bottom: 0;
      }
      .extracted-section h3 {
        margin: 0 0 12px 0;
        font-size: 16px;
        color: #1f2937;
        border-bottom: 2px solid #2563eb;
        padding-bottom: 6px;
      }
      .info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }
      .info-item {
        background: white;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
      }
      .info-item label {
        display: block;
        font-size: 12px;
        color: #6b7280;
        margin-bottom: 4px;
        font-weight: 500;
      }
      .info-item .value {
        font-size: 14px;
        color: #1f2937;
        font-weight: 500;
      }
      .tag-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .tag-item {
        background: white;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 500;
        border: 1px solid #e5e7eb;
      }
      .badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
      }
      .badge.positive {
        background: #dcfce7;
        color: #166534;
      }
      .badge.negative {
        background: #fee2e2;
        color: #991b1b;
      }
      .badge.neutral {
        background: #f1f5f9;
        color: #475569;
      }
      .link {
        color: #2563eb;
        text-decoration: none;
        word-break: break-all;
      }
      .link:hover {
        text-decoration: underline;
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
        color: #475569;
        font-size: 13px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        background: #f1f5f9;
        padding: 6px 10px;
        border-radius: 8px;
      }
      .legend-symbol {
        width: 14px;
        height: 14px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <script>
      if (window.self !== window.top) {
        document.body.classList.add('in-iframe');
      }
    </script>
    <div class="container">
      <header>
        <h1 id="graph-page-title">ğŸ•¸ï¸ ç¤¾åª’å›¾è°±</h1>
        <p>å±•ç¤ºç¤¾äº¤åª’ä½“å†…å®¹çš„çŸ¥è¯†å›¾è°±ï¼ŒåŒ…æ‹¬å…³é”®è¯ã€å®ä½“ã€ä¸»é¢˜å’Œæƒ…æ„Ÿæ ‡ç­¾çš„å…³ç³»ç½‘ç»œ</p>
        <p id="graph-doc-type-hint" class="info" style="margin-top: 12px;"></p>
        <p id="graph-structure-hint" class="info" style="margin-top: 8px;"></p>
        <div class="nav-links">
          <a href="social-media-visualization.html">â† è¿”å›ç¤¾äº¤åª’ä½“æ•°æ®</a>
        </div>
      </header>

      <div class="stats" id="stats">
        <div class="stat-card">
          <h3>èŠ‚ç‚¹æ€»æ•°</h3>
          <div class="value" id="stat-nodes">0</div>
        </div>
        <div class="stat-card">
          <h3>è¾¹æ€»æ•°</h3>
          <div class="value" id="stat-edges">0</div>
        </div>
        <div class="stat-card">
          <h3>å¸–å­èŠ‚ç‚¹</h3>
          <div class="value" id="stat-posts">0</div>
        </div>
        <div class="stat-card">
          <h3>å…³é”®è¯èŠ‚ç‚¹</h3>
          <div class="value" id="stat-keywords">0</div>
        </div>
      </div>

      <div class="controls">
        <div class="controls-row">
          <label>å¼€å§‹æ—¥æœŸï¼š</label>
          <input type="date" id="filter-start" />
          <label>ç»“æŸæ—¥æœŸï¼š</label>
          <input type="date" id="filter-end" />
          <label>å¹³å°ï¼š</label>
          <select id="filter-platform">
            <option value="">å…¨éƒ¨</option>
            <option value="reddit">Reddit</option>
            <option value="twitter">Twitter</option>
            <option value="facebook">Facebook</option>
          </select>
          <label>ä¸»é¢˜ï¼š</label>
          <input type="text" id="filter-topic" placeholder="å¯é€‰ï¼Œå¦‚ï¼šlottery strategy" />
          <button onclick="loadGraph()">åŠ è½½å›¾è°±</button>
        </div>
        <div class="controls-row">
          <label>
            <input type="checkbox" id="show-posts" checked /> æ˜¾ç¤ºå¸–å­èŠ‚ç‚¹
          </label>
          <label>
            <input type="checkbox" id="show-keywords" checked /> æ˜¾ç¤ºå…³é”®è¯èŠ‚ç‚¹
          </label>
          <label>
            <input type="checkbox" id="show-entities" checked /> æ˜¾ç¤ºå®ä½“èŠ‚ç‚¹
          </label>
          <label>
            <input type="checkbox" id="show-topics" checked /> æ˜¾ç¤ºä¸»é¢˜èŠ‚ç‚¹
          </label>
          <label>
            <input type="checkbox" id="show-sentiment" checked /> æ˜¾ç¤ºæƒ…æ„Ÿæ ‡ç­¾
          </label>
        </div>
      </div>

      <div class="graph-container" id="social-graph-container">
        <h2>
          å†…å®¹å›¾è°±
          <div class="graph-header-actions">
            <button class="fullscreen-btn" id="social-fullscreen-btn" onclick="toggleSocialFullscreen()">
              <span id="social-fullscreen-icon">â›¶</span>
              <span id="social-fullscreen-text">å…¨å±</span>
            </button>
          </div>
        </h2>
        <div class="legend" id="social-graph-legend"></div>
        <div id="graph-chart"></div>
      </div>
    </div>

    <!-- å…¨å±è§†å›¾å®¹å™¨ -->
    <div id="graph-fullscreen-view">
      <div class="graph-container" id="fullscreen-graph-container">
        <h2>
          å†…å®¹å›¾è°±
          <div class="graph-header-actions">
            <button class="fullscreen-btn" id="fullscreen-exit-btn" onclick="toggleSocialFullscreen()">
              <span>â›¶</span>
              <span>é€€å‡ºå…¨å±</span>
            </button>
          </div>
        </h2>
        <div class="legend" id="fullscreen-social-legend"></div>
        <div id="fullscreen-graph-chart"></div>
      </div>
    </div>

    <!-- Postè¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="post-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>å¸–å­è¯¦æƒ…</h2>
          <span class="close" onclick="closePostModal()">&times;</span>
        </div>
        <div id="post-detail-content"></div>
      </div>
    </div>

    <script>
      let graphChart = null;
      let currentGraphData = null;
      let nodeDataMap = {}; // å­˜å‚¨èŠ‚ç‚¹åŸå§‹æ•°æ®ï¼Œç”¨äºè¯¦æƒ…å±•ç¤º
      let computedNodeColors = {}; // åŸºäºæƒ…ç»ªæ±‡èšè®¡ç®—çš„èŠ‚ç‚¹é¢œè‰²
      let graphConfig = { nodeTypes: ['Post', 'Keyword', 'Entity', 'Topic', 'SentimentTag', 'User', 'Subreddit'], nodeLabels: {}, typeLabel: 'ç¤¾åª’å›¾è°±' };

      const SOCIAL_NODE_COLORS = { 'Post': '#2563eb', 'Keyword': '#10b981', 'Entity': '#f59e0b', 'Topic': '#8b5cf6', 'SentimentTag': '#ec4899', 'User': '#64748b', 'Subreddit': '#14b8a6' };
      async function loadGraphDocTypeHint() {
        const hintEl = document.getElementById('graph-doc-type-hint');
        const structureEl = document.getElementById('graph-structure-hint');
        const statsEl = document.getElementById('stats');
        const legendEl = document.getElementById('social-graph-legend');
        const controlsRow2 = document.querySelector('.controls-row:nth-child(2)');
        if (!hintEl || !structureEl) return;
        try {
          const projectKey = window.MarketApp?.getProjectKey?.() || '';
          const query = projectKey ? `?project_key=${encodeURIComponent(projectKey)}` : '';
          const response = await fetch(`/api/v1/project-customization/graph-config${query}`);
          const data = response.ok ? (await response.json())?.data : null;
          const graphDocTypes = data?.graph_doc_types || {};
          const labels = data?.graph_type_labels || {};
          const graphNodeTypes = data?.graph_node_types || {};
          const graphNodeLabels = data?.graph_node_labels || {};
          const graphEdgeTypes = data?.graph_edge_types || {};
          const relationLabels = data?.graph_relation_labels || {};
          const socialTypes = Array.isArray(graphDocTypes.social) ? graphDocTypes.social : ['social_sentiment', 'social_feed'];
          const socialNodeTypes = Array.isArray(graphNodeTypes.social) ? graphNodeTypes.social : ['Post', 'Keyword', 'Entity', 'Topic', 'SentimentTag', 'User', 'Subreddit'];
          const socialEdgeTypes = Array.isArray(graphEdgeTypes.social) ? graphEdgeTypes.social : ['MENTIONS_KEYWORD', 'MENTIONS_ENTITY', 'HAS_TOPIC', 'HAS_SENTIMENT', 'AUTHORED_BY', 'IN_SUBREDDIT', 'CO_OCCURS'];
          const socialLabel = labels.social || 'ç¤¾åª’å›¾è°±';
          graphConfig = { nodeTypes: socialNodeTypes, nodeLabels: graphNodeLabels, typeLabel: socialLabel };
          const titleEl = document.getElementById('graph-page-title');
          if (titleEl) titleEl.textContent = `ğŸ•¸ï¸ ${socialLabel}`;
          hintEl.textContent = `${socialLabel}æ•°æ®ç±»å‹: ${socialTypes.join(', ')}`;
          const edgeLabels = socialEdgeTypes.map((e) => relationLabels[e] ? `${e}(${relationLabels[e]})` : e);
          structureEl.textContent = `èŠ‚ç‚¹ç±»å‹: ${socialNodeTypes.join(', ')}ï¼›å…³ç³»ç±»å‹: ${edgeLabels.join(', ')}`;
          const lbl = (t) => graphNodeLabels[t] || t;
          if (statsEl) {
            statsEl.innerHTML = `<div class="stat-card"><h3>èŠ‚ç‚¹æ€»æ•°</h3><div class="value" id="stat-nodes">0</div></div><div class="stat-card"><h3>è¾¹æ€»æ•°</h3><div class="value" id="stat-edges">0</div></div>` +
              socialNodeTypes.map((t) => `<div class="stat-card"><h3>${lbl(t)}èŠ‚ç‚¹</h3><div class="value" id="stat-${t}">0</div></div>`).join('');
          }
          if (controlsRow2) {
            const showMap = { Post: 'show-posts', Keyword: 'show-keywords', Entity: 'show-entities', Topic: 'show-topics', SentimentTag: 'show-sentiment' };
            controlsRow2.innerHTML = socialNodeTypes.map((t) => {
              const id = showMap[t] || ('show-' + t.toLowerCase());
              return `<label><input type="checkbox" id="${id}" checked /> æ˜¾ç¤º${lbl(t)}èŠ‚ç‚¹</label>`;
            }).join('');
          }
          const legendHtml = socialNodeTypes.map((t) => {
            const color = SOCIAL_NODE_COLORS[t] || '#94a3b8';
            const label = graphNodeLabels[t] || t;
            return `<div class="legend-item"><span class="legend-symbol" style="background:${color};"></span>${t} ${label}</div>`;
          }).join('');
          if (legendEl) legendEl.innerHTML = legendHtml;
          const fullscreenLegend = document.getElementById('fullscreen-social-legend');
          if (fullscreenLegend) fullscreenLegend.innerHTML = legendHtml;
        } catch (error) {
          hintEl.textContent = 'å½“å‰å›¾è°±ç±»å‹: social_sentiment, social_feed';
          structureEl.textContent = 'èŠ‚ç‚¹ç±»å‹: Post, Keyword, Entity, Topic, SentimentTag, User, Subredditï¼›å…³ç³»ç±»å‹: MENTIONS_KEYWORD, MENTIONS_ENTITY, HAS_TOPIC, HAS_SENTIMENT, AUTHORED_BY, IN_SUBREDDIT, CO_OCCURS';
        }
      }

      // åˆå§‹åŒ–å›¾è¡¨
      function initChart() {
        const chartEl = document.getElementById('graph-chart');
        if (!chartEl) return;
        
        // ç¡®ä¿å®¹å™¨æ˜¯divï¼Œè€Œä¸æ˜¯åŒ…å«loadingçš„div
        if (chartEl.querySelector('.loading') || chartEl.querySelector('.error') || chartEl.querySelector('.info')) {
          chartEl.innerHTML = '';
        }
        
        graphChart = echarts.init(chartEl);
        
        // è®¾ç½®åˆå§‹ç©ºå›¾è¡¨
        graphChart.setOption({
          title: {
            text: 'è¯·é€‰æ‹©ç­›é€‰æ¡ä»¶å¹¶ç‚¹å‡»"åŠ è½½å›¾è°±"',
            left: 'center',
            top: 'middle',
            textStyle: {
              color: '#94a3b8',
              fontSize: 16
            }
          }
        });
      }

      // åŠ è½½å›¾è°±æ•°æ®
      async function loadGraph() {
        const start = document.getElementById('filter-start').value;
        const end = document.getElementById('filter-end').value;
        const platform = document.getElementById('filter-platform').value;
        const topic = document.getElementById('filter-topic').value.trim();
        
        const chartEl = document.getElementById('graph-chart');
        
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        if (graphChart) {
          graphChart.dispose();
          graphChart = null;
        }
        chartEl.innerHTML = '<div class="loading"><span class="spinner"></span>åŠ è½½ä¸­...</div>';
        
        try {
          const projectKey = window.MarketApp?.getProjectKey?.() || '';
          const params = new URLSearchParams();
          if (projectKey) params.append('project_key', projectKey);
          if (start) params.append('start_date', start);
          if (end) params.append('end_date', end);
          if (platform) params.append('platform', platform);
          if (topic) params.append('topic', topic);
          params.append('limit', '100');
          const response = await fetch(`/api/v1/admin/content-graph?${params}`);
          
          let graphData;
          if (!response.ok) {
            // å°è¯•è§£æé”™è¯¯å“åº”
            try {
              const errorData = await response.json();
              // å¦‚æœé”™è¯¯å“åº”ä¸­åŒ…å«nodeså’Œedgeså­—æ®µï¼Œä»ç„¶ä½¿ç”¨å®ƒ
              if (errorData.nodes !== undefined && errorData.edges !== undefined) {
                graphData = { nodes: errorData.nodes || [], edges: errorData.edges || [] };
              } else {
                throw new Error(errorData.error || `HTTP ${response.status}`);
              }
            } catch (e) {
              // å¦‚æœæ— æ³•è§£æï¼Œä½¿ç”¨ç©ºæ•°æ®
              console.warn('APIè¿”å›é”™è¯¯ï¼Œä½¿ç”¨ç©ºæ•°æ®:', e);
              graphData = { nodes: [], edges: [] };
            }
          } else {
            graphData = await response.json();
          }
          
          console.log('APIè¿”å›çš„æ•°æ®:', graphData);
          
          // ç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
          if (!graphData.nodes) graphData.nodes = [];
          if (!graphData.edges) graphData.edges = [];
          
          // é‡æ–°åˆå§‹åŒ–å›¾è¡¨å®¹å™¨
          chartEl.innerHTML = '';
          initChart();
          
          // æ¸²æŸ“å›¾è°±
          renderGraph(graphData);
          
        } catch (err) {
          console.error('åŠ è½½å›¾è°±å¤±è´¥:', err);
          // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œä½†ä¹Ÿè¦åˆå§‹åŒ–å›¾è¡¨å’Œç»Ÿè®¡ä¿¡æ¯
          const chartEl = document.getElementById('graph-chart');
          chartEl.innerHTML = '';
          initChart();
          
          if (document.getElementById('stat-nodes')) document.getElementById('stat-nodes').textContent = '0';
          if (document.getElementById('stat-edges')) document.getElementById('stat-edges').textContent = '0';
          (graphConfig.nodeTypes || []).forEach((t) => {
            const el = document.getElementById('stat-' + t);
            if (el) el.textContent = '0';
          });
          
          // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error';
          errorDiv.textContent = `åŠ è½½å¤±è´¥: ${err.message}`;
          chartEl.appendChild(errorDiv);
        }
      }

      // æ¸²æŸ“å›¾è°±
      function renderGraph(graphData) {
        if (!graphChart) {
          console.error('å›¾è¡¨æœªåˆå§‹åŒ–');
          return;
        }
        
        if (!graphData) {
          console.error('å›¾è°±æ•°æ®ä¸ºç©º');
          return;
        }
        
        console.log('å›¾è°±æ•°æ®:', graphData);
        
        const nodes = graphData.nodes || [];
        const edges = graphData.edges || [];
        
        console.log(`èŠ‚ç‚¹æ•°: ${nodes.length}, è¾¹æ•°: ${edges.length}`);
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ ¹æ®é¡¹ç›®é…ç½®çš„èŠ‚ç‚¹ç±»å‹ï¼‰
        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        if (statNodes) statNodes.textContent = nodes.length || 0;
        if (statEdges) statEdges.textContent = edges.length || 0;
        (graphConfig.nodeTypes || []).forEach((t) => {
          const el = document.getElementById('stat-' + t);
          if (el) el.textContent = nodes.filter((n) => n.type === t).length || 0;
        });
        
        if (nodes.length === 0) {
          const chartEl = document.getElementById('graph-chart');
          const infoDiv = document.createElement('div');
          infoDiv.className = 'info';
          infoDiv.innerHTML = 'æš‚æ— å›¾è°±æ•°æ®ã€‚è¯·è°ƒæ•´ç­›é€‰æ¡ä»¶æˆ–ç¡®ä¿æ•°æ®åº“ä¸­æœ‰ç¤¾äº¤åª’ä½“æ•°æ®ã€‚';
          chartEl.innerHTML = '';
          chartEl.appendChild(infoDiv);
          return;
        }
        
        // æŒ‰èŠ‚ç‚¹ç±»å‹åˆ†ç±»ï¼ˆæ ¹æ®é¡¹ç›®é…ç½®ï¼Œå¹¶è¡¥å……æ•°æ®ä¸­å®é™…å­˜åœ¨çš„ç±»å‹ï¼‰
        const configTypes = graphConfig.nodeTypes || ['Post', 'Keyword', 'Entity', 'Topic', 'SentimentTag', 'User', 'Subreddit'];
        const actualTypes = [...new Set(nodes.map((n) => n.type))];
        const allTypes = [...new Set([...configTypes, ...actualTypes])];
        const categoryMap = {};
        allTypes.forEach((t, i) => { categoryMap[t] = i; });
        const categories = allTypes.map((name) => ({ name }));
        lastCategories = categories;
        
        // æ¸…ç©ºèŠ‚ç‚¹æ•°æ®æ˜ å°„
        nodeDataMap = {};
        computedNodeColors = {};
        
        // å…ˆè®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„åº¦æ•°ï¼ˆè¿æ¥çš„è¾¹æ•°ï¼‰
        const nodeDegrees = {};
        nodes.forEach(node => {
          const nodeId = `${node.type}_${node.id}`;
          nodeDegrees[nodeId] = 0;
        });
        
        edges.forEach(edge => {
          const fromId = `${edge.from.type}_${edge.from.id}`;
          const toId = `${edge.to.type}_${edge.to.id}`;
          if (nodeDegrees.hasOwnProperty(fromId)) {
            nodeDegrees[fromId]++;
          }
          if (nodeDegrees.hasOwnProperty(toId)) {
            nodeDegrees[toId]++;
          }
        });
        
        // æ‰¾åˆ°æœ€å°å’Œæœ€å¤§åº¦æ•°ï¼Œç”¨äºå½’ä¸€åŒ–
        const degrees = Object.values(nodeDegrees);
        const minDegree = Math.min(...degrees, 0);
        const maxDegree = Math.max(...degrees, 1);
        const degreeRange = maxDegree - minDegree || 1; // é¿å…é™¤é›¶
        
        console.log(`èŠ‚ç‚¹åº¦æ•°èŒƒå›´: ${minDegree} - ${maxDegree}`);

        // å„ç±»å‹çš„åº¦æ•°èŒƒå›´ï¼ˆé¿å…è¢«Postç­‰é«˜å€¼æ·¹æ²¡ï¼‰
        const degMinByType = {};
        const degMaxByType = {};
        nodes.forEach(n => {
          const t = n.type;
          const id = `${n.type}_${n.id}`;
          const d = nodeDegrees[id] || 0;
          if (!(t in degMinByType)) { degMinByType[t] = d; degMaxByType[t] = d; }
          else {
            if (d < degMinByType[t]) degMinByType[t] = d;
            if (d > degMaxByType[t]) degMaxByType[t] = d;
          }
        });

        // è§„èŒƒåŒ–è¾¹æƒé‡ï¼ˆç”¨äºè¾¹é•¿/ç²—ç»†/ä¼ æ’­ï¼‰
        const edgeRawWeights = edges.map(e => (e.properties && e.properties.weight) || 1);
        const wMin = Math.min(...edgeRawWeights, 1);
        const wMax = Math.max(...edgeRawWeights, 1);
        const wRange = (wMax - wMin) || 1;

        // è®¡ç®—Postææ€§æ˜ å°„ï¼ˆ-1/0/1ï¼‰ï¼Œå¹¶ä¸ºPosté¢„è®¾é¢œè‰²
        const postPolarityMap = {};
        nodes.forEach(n => {
          if (n.type === 'Post') {
            const ori = (n.sentiment_orientation || n.properties?.sentiment_orientation || '').toLowerCase();
            const pol = ori === 'positive' ? 1 : ori === 'negative' ? -1 : 0;
            postPolarityMap[`${n.type}_${n.id}`] = pol;
          }
        });

        // è®¡ç®—Postå†…ç¦€å¼ºåº¦ï¼ˆåŸºäºå†…å®¹ä¸°å¯Œåº¦/é•¿åº¦/æ ‡ç­¾ç­‰ï¼Œå½’ä¸€åŒ–åˆ°[0,1]ï¼‰
        const postIntrinsicMap = {};
        nodes.forEach(n => {
          if (n.type !== 'Post') return;
          const text = (n.text || '').trim();
          const lenNorm = Math.min(1, text.length / 280);
          const topicBoost = n.topic ? 1 : 0;
          const keyPhrases = Array.isArray(n.key_phrases) ? n.key_phrases.length : 0;
          const emotionWords = Array.isArray(n.emotion_words) ? n.emotion_words.length : 0;
          const sentimentTags = Array.isArray(n.sentiment_tags) ? n.sentiment_tags.length : 0;
          const kpNorm = Math.min(1, keyPhrases / 5);
          const emoNorm = Math.min(1, emotionWords / 5);
          const tagNorm = Math.min(1, sentimentTags / 3);
          const raw = 0.4 * lenNorm + 0.2 * topicBoost + 0.2 * kpNorm + 0.1 * emoNorm + 0.1 * tagNorm;
          postIntrinsicMap[`${n.type}_${n.id}`] = Math.max(0, Math.min(1, raw));
        });

        // ä¼ æ’­Postå†…ç¦€å¼ºåº¦åˆ°å‘¨è¾¹èŠ‚ç‚¹ï¼šæŒ‰è¾¹æƒé‡åŠ æƒå¹³å‡ï¼ˆæ— æƒé‡çš„è¾¹æŒ‰ç±»å‹ç»™é»˜è®¤ä¼ æ’­æƒé‡ï¼‰
        const nodePropInfluence = {};
        const nodePropWeight = {};
        edges.forEach(e => {
          const fromId = `${e.from.type}_${e.from.id}`;
          const toId = `${e.to.type}_${e.to.id}`;
          const rawW = (e.properties && e.properties.weight) ? e.properties.weight : null;
          let propW;
          if (typeof rawW === 'number') {
            const norm = (wRange > 0) ? (rawW - wMin) / wRange : 1;
            propW = Math.max(0.3, Math.min(1, norm)); // ç»™æœ€å°ä¼ æ’­æƒé‡ï¼Œé¿å…ä¸º0
          } else {
            // æ— æƒé‡ï¼šæŒ‰è¾¹ç±»å‹ç»™é»˜è®¤ä¼ æ’­æƒé‡
            if (e.type === 'HAS_SENTIMENT') propW = 0.8;
            else if (e.type === 'HAS_TOPIC') propW = 0.6;
            else if (e.type === 'MENTIONS_ENTITY') propW = 0.5;
            else if (e.type === 'AUTHORED_BY' || e.type === 'IN_SUBREDDIT') propW = 0.4;
            else if (e.type === 'CO_OCCURS') propW = 0.5;
            else propW = 0.5;
          }
          const fromPost = postIntrinsicMap[fromId];
          const toPost = postIntrinsicMap[toId];
          if (fromPost !== undefined) {
            nodePropInfluence[toId] = (nodePropInfluence[toId] || 0) + propW * fromPost;
            nodePropWeight[toId] = (nodePropWeight[toId] || 0) + propW;
          }
          if (toPost !== undefined) {
            nodePropInfluence[fromId] = (nodePropInfluence[fromId] || 0) + propW * toPost;
            nodePropWeight[fromId] = (nodePropWeight[fromId] || 0) + propW;
          }
        });
        Object.keys(nodePropInfluence).forEach(id => {
          const w = nodePropWeight[id] || 0;
          nodePropInfluence[id] = w > 0 ? (nodePropInfluence[id] / w) : 0;
        });

        // æƒ…ç»ªå•æ­¥åŠ æƒæ±‡èšï¼šå°†Postæƒ…ç»ªæ²¿è¾¹æ±‡èšåˆ°éPostèŠ‚ç‚¹
        const aggSum = {}; // Î£(wÂ·sent)
        const aggW = {};   // Î£(w)
        edges.forEach(e => {
          const fromId = `${e.from.type}_${e.from.id}`;
          const toId = `${e.to.type}_${e.to.id}`;
          const w = (e.properties && e.properties.weight) ? e.properties.weight : 1;
          const fromPol = postPolarityMap[fromId];
          const toPol = postPolarityMap[toId];
          if (fromPol !== undefined) {
            // æ±‡èšåˆ°å¯¹ç«¯
            aggSum[toId] = (aggSum[toId] || 0) + fromPol * w;
            aggW[toId] = (aggW[toId] || 0) + w;
          } else if (toPol !== undefined) {
            // æ±‡èšåˆ°å¯¹ç«¯
            aggSum[fromId] = (aggSum[fromId] || 0) + toPol * w;
            aggW[fromId] = (aggW[fromId] || 0) + w;
          }
        });

        // è®¡ç®—èŠ‚ç‚¹é¢œè‰²ï¼ˆPost ç”¨è‡ªèº«ææ€§ï¼Œå…¶ä»–ç”¨æ±‡èšç»“æœï¼‰
        nodes.forEach(n => {
          const nodeId = `${n.type}_${n.id}`;
          if (n.type === 'Post') {
            const pol = postPolarityMap[nodeId] ?? 0;
            computedNodeColors[nodeId] = sentimentColor(pol);
          } else {
            const sum = aggSum[nodeId] || 0;
            const weight = aggW[nodeId] || 0;
            const avg = weight > 0 ? (sum / weight) : 0; // [-1,1]
            computedNodeColors[nodeId] = sentimentColor(avg);
          }
        });
        
        // è½¬æ¢èŠ‚ç‚¹æ•°æ®
        const echartsNodes = nodes.map(node => {
          const category = categoryMap[node.type] || 0;
          // èŠ‚ç‚¹åç§°ï¼šæ ¹æ®ç±»å‹é€‰æ‹©ä¸åŒçš„å±æ€§
          // æ³¨æ„ï¼šåç«¯exporterä½¿ç”¨**node.propertieså±•å¼€ï¼Œæ‰€ä»¥å±æ€§åœ¨é¡¶å±‚ï¼Œä¸åœ¨propertiesä¸­
          let nodeName = node.id;
          if (node.type === 'Post') {
            // ä¼˜å…ˆæ˜¾ç¤ºtextï¼ˆæ ‡é¢˜ï¼‰ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤ºIDï¼Œä¸æ˜¾ç¤ºURL
            nodeName = node.text || `Post ${node.id}`;
          } else if (node.type === 'Keyword') {
            // å…³é”®è¯ç»Ÿä¸€å°å†™æ˜¾ç¤ºï¼Œé¿å…å¤§å°å†™é€ æˆçš„è§†è§‰é”™ä½
            nodeName = (node.text || node.id).toLowerCase();
          } else if (node.type === 'Entity') {
            nodeName = (node.canonical_name || node.text || node.id).toLowerCase();
          } else if (node.type === 'Topic' || node.type === 'SentimentTag') {
            nodeName = (node.label || node.id).toLowerCase();
          } else if (node.type === 'User') {
            nodeName = (node.username || node.id).toLowerCase();
          } else if (node.type === 'Subreddit') {
            nodeName = 'r/' + (node.name || node.id).toLowerCase();
          }
          
          const nodeId = `${node.type}_${node.id}`;
          // ä¿å­˜åŸå§‹èŠ‚ç‚¹æ•°æ®
          nodeDataMap[nodeId] = node;
          
          // è·å–èŠ‚ç‚¹çš„åº¦æ•°ï¼ˆç±»å‹èŒƒå›´å½’ä¸€åŒ–ï¼‰
          const degree = nodeDegrees[nodeId] || 0;
          const tMin = (degMinByType[node.type] !== undefined) ? degMinByType[node.type] : minDegree;
          const tMax = (degMaxByType[node.type] !== undefined) ? degMaxByType[node.type] : maxDegree;
          const tRange = (tMax - tMin) || 1;
          
          const propInfluence = nodePropInfluence[nodeId] || 0;
          return {
            id: nodeId,
            name: nodeName,
            value: degree, // ä½¿ç”¨åº¦æ•°ä½œä¸ºvalueï¼Œç”¨äºtooltipæ˜¾ç¤º
            category: category,
              symbol: getNodeSymbol(node.type),
            symbolSize: getNodeSizeCombined(node.type, degree, tMin, tMax, tRange, propInfluence),
            itemStyle: {
              color: computedNodeColors[nodeId] || getNodeColor(node.type)
            },
            label: {
              show: true,
              formatter: (params) => {
                const name = params.name || '';
                return name.length > 20 ? name.substring(0, 20) + '...' : name;
              }
            }
          };
        });
        
        // è½¬æ¢è¾¹æ•°æ®
        const echartsLinks = edges.map(edge => {
          const fromId = `${edge.from.type}_${edge.from.id}`;
          const toId = `${edge.to.type}_${edge.to.id}`;
          const rawW = (edge.properties && edge.properties.weight) ? edge.properties.weight : 1;
          const normW = (rawW - wMin) / wRange; // [0,1]
          const edgeValue = 1 - normW; // å¼ºâ†’çŸ­
          const width = 1 + 2 * normW; // 1â€“3
          // ä»…å¯¹æƒ…ç»ªç›¸å…³çš„è¾¹ç€è‰²ï¼ˆPostâ†’Topic / Postâ†’SentimentTagï¼‰
          let edgeColor = '#cbd5e1';
          if (edge.type === 'HAS_TOPIC' || edge.type === 'HAS_SENTIMENT') {
            const pol = (postPolarityMap[fromId] !== undefined) ? postPolarityMap[fromId]
              : (postPolarityMap[toId] !== undefined ? postPolarityMap[toId] : 0);
            edgeColor = sentimentColor(pol);
          }
          return {
            source: fromId,
            target: toId,
            value: edgeValue,
            lineStyle: {
              width: Math.max(1, Math.min(3, width)),
              curveness: 0,
              color: edgeColor
            }
          };
        }).filter(link => {
          // è¿‡æ»¤æ‰æºèŠ‚ç‚¹æˆ–ç›®æ ‡èŠ‚ç‚¹ä¸å­˜åœ¨çš„è¾¹
          const sourceExists = echartsNodes.some(n => n.id === link.source);
          const targetExists = echartsNodes.some(n => n.id === link.target);
          return sourceExists && targetExists;
        });
        
        console.log(`è½¬æ¢åèŠ‚ç‚¹æ•°: ${echartsNodes.length}, è¾¹æ•°: ${echartsLinks.length}`);
        
        // æ¸…é™¤å®¹å™¨ä¸­çš„æ‰€æœ‰æç¤ºæ–‡å­—
        const chartEl = document.getElementById('graph-chart');
        if (chartEl) {
          // ç§»é™¤æ‰€æœ‰æç¤ºå…ƒç´ 
          const loadingEl = chartEl.querySelector('.loading');
          const errorEl = chartEl.querySelector('.error');
          const infoEl = chartEl.querySelector('.info');
          if (loadingEl) loadingEl.remove();
          if (errorEl) errorEl.remove();
          if (infoEl) infoEl.remove();
        }
        
        // ç»Ÿè®¡ä¿¡æ¯å·²åœ¨å‰é¢æ›´æ–°ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤æ›´æ–°
        
        const option = {
          title: {
            show: false  // æ˜ç¡®éšè—titleï¼Œæ¸…é™¤åˆå§‹æç¤ºæ–‡å­—
          },
          tooltip: {
            trigger: 'item',
            formatter: (params) => {
              if (params.dataType === 'node') {
                const nodeData = nodeDataMap[params.data.id];
                const degree = params.data.value || 0;
                let tooltip = `${params.data.name}<br/>ç±»å‹: ${getNodeTypeName(params.data.category)}<br/>è¿æ¥æ•°: ${degree}`;
                if (nodeData && nodeData.type === 'Post') {
                  // å±æ€§åœ¨é¡¶å±‚ï¼ˆexporterå±•å¼€åï¼‰
                  if (nodeData.platform) tooltip += `<br/>å¹³å°: ${nodeData.platform}`;
                  if (nodeData.publish_date) tooltip += `<br/>å‘å¸ƒæ—¶é—´: ${nodeData.publish_date}`;
                  if (nodeData.sentiment_orientation) {
                    tooltip += `<br/>æƒ…æ„Ÿ: ${nodeData.sentiment_orientation}`;
                  }
                  tooltip += '<br/><span style="color: #64748b; font-size: 12px;">ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…</span>';
                }
                return tooltip;
              } else {
                return `${params.data.source} â†’ ${params.data.target}`;
              }
            }
          },
          legend: { show: false },
          series: [{
            name: 'å†…å®¹å›¾è°±',
            type: 'graph',
            layout: 'force',
            data: echartsNodes,
            links: echartsLinks,
            categories: categories,
            roam: true,
            label: {
              show: true,
              position: 'right',
              formatter: '{b}'
            },
            labelLayout: {
              hideOverlap: true
            },
            scaleLimit: {
              min: 0.05,
              max: 3
            },
            lineStyle: {
              color: 'source',
              curveness: 0  // ç›´çº¿è¿æ¥
            },
            emphasis: {
              focus: 'adjacency',
              lineStyle: {
                width: 10
              }
            },
            force: {
              repulsion: 1500,  // å¢åŠ æ’æ–¥åŠ›ï¼Œè®©èŠ‚ç‚¹é—´è·æ›´å¤§
              gravity: 0.05,     // å‡å°é‡åŠ›ï¼Œè®©èŠ‚ç‚¹åˆ†å¸ƒæ›´åˆ†æ•£
              edgeLength: [120, 300],   // æ ¹æ®link.valueæ˜ å°„ï¼ˆå¼ºâ†’çŸ­ï¼‰
              layoutAnimation: true
            }
          }]
        };
        
        graphChart.setOption(option);
        currentGraphData = graphData;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        graphChart.on('click', (params) => {
          if (params.dataType === 'node') {
            const nodeData = nodeDataMap[params.data.id];
            if (nodeData && nodeData.type === 'Post') {
              showPostDetail(nodeData);
            }
          }
        });
        
        // å¦‚æœå½“å‰æ˜¯å…¨å±çŠ¶æ€ï¼Œæ›´æ–°å…¨å±å›¾è¡¨
        if (isFullscreen && fullscreenChart) {
          fullscreenChart.setOption(option);
          setTimeout(() => {
            fullscreenChart.resize();
          }, 100);
        }
      }

      // æ ¹æ®åº¦æ•°ä¸Postå†…ç¦€ä¼ æ’­è”åˆè®¡ç®—èŠ‚ç‚¹å¤§å°
      function getNodeSizeCombined(nodeType, degree, minDegree, maxDegree, degreeRange, propInfluence) {
        // åŸºç¡€å¤§å°ï¼ˆæœ€å°èŠ‚ç‚¹å¤§å°ï¼‰- å‡å°äº†åŸºç¡€å¤§å°
        const baseSize = {
          'Post': 12,
          'Keyword': 8,
          'Entity': 12,
          'Topic': 16,
          'SentimentTag': 12,
          'User': 12,
          'Subreddit': 12
        };
        const minSize = baseSize[nodeType] || 8;
        
        // æœ€å¤§å¤§å°ï¼ˆæœ€å¤§èŠ‚ç‚¹å¤§å°ï¼‰- å‡å°äº†æœ€å¤§å¤§å°
        const maxSize = {
          'Post': 35,
          'Keyword': 28,
          'Entity': 38,
          'Topic': 44,
          'SentimentTag': 48,
          'User': 36,
          'Subreddit': 36
        };
        const maxNodeSize = maxSize[nodeType] || 30;
        
        // å¦‚æœåº¦æ•°ä¸º0ï¼Œä½¿ç”¨æœ€å°å¤§å°
        if (degree === 0) {
          // å¯¹äºéPostèŠ‚ç‚¹ï¼Œä»ç„¶å…è®¸ä¼ æ’­å½±å“æ‹‰èµ·ä¸€äº›å¯è¯»æ€§
          if (nodeType !== 'Post') {
            const pf = Math.max(0, Math.min(1, propInfluence || 0));
            // ç±»å‹ç¼©æ”¾ï¼Œæå‡éPost/Keywordçš„è§‚æ„Ÿ
            const typeScale = (nodeType === 'Topic' || nodeType === 'SentimentTag') ? 1.25
              : (nodeType === 'Entity' || nodeType === 'User' || nodeType === 'Subreddit') ? 1.2 : 1.0;
            let size0 = minSize + (maxNodeSize - minSize) * 0.5 * Math.min(1, pf * typeScale); // æœ€é«˜æ‹‰èµ·50%
            // ç±»å‹åº•çº¿
            if (nodeType === 'Topic') size0 = Math.max(size0, 16);
            if (nodeType === 'Entity' || nodeType === 'User' || nodeType === 'Subreddit') size0 = Math.max(size0, 14);
            if (nodeType === 'SentimentTag') size0 = Math.max(size0, 16);
            return Math.round(size0);
          }
          return minSize;
        }
        
        // å½’ä¸€åŒ–åº¦æ•°åˆ°0-1èŒƒå›´
        const normalizedDegree = (degree - minDegree) / degreeRange;
        // æŒ‰ç±»å‹è®¾ç½®æ”¾å¤§æŒ‡æ•°ï¼ˆè¶Šå¤§è¶Šå¼ºè°ƒâ€œè¿å¾—å¤šå°±æ›´å¤§â€ï¼‰
        const expMap = {
          'Post': 0.7,
          'Keyword': 0.85,
          'Entity': 0.85,
          'Topic': 0.9,
          'SentimentTag': 1.2,
          'User': 0.85,
          'Subreddit': 0.85
        };
        const exp = expMap[nodeType] || 0.85;
        const degFactor = Math.pow(Math.max(0, Math.min(1, normalizedDegree)), exp);
        const propFactor = Math.max(0, Math.min(1, propInfluence || 0));

        // ç±»å‹æƒé‡ï¼šTag/Topicæ›´ä¾èµ–ä¼ æ’­ï¼ŒKeyword/Entity/Useræ¬¡ä¹‹ï¼ŒPostä¸»è¦çœ‹è‡ªèº«åº¦æ•°
        const weightMap = {
          'Post': { d: 0.9, p: 0.1 },
          'Topic': { d: 0.35, p: 0.65 },
          'SentimentTag': { d: 0.7, p: 0.3 },
          'Keyword': { d: 0.6, p: 0.4 },
          'Entity': { d: 0.55, p: 0.45 },
          'User': { d: 0.55, p: 0.45 },
          'Subreddit': { d: 0.55, p: 0.45 }
        };
        const wp = weightMap[nodeType] || { d: 0.6, p: 0.4 };
        let combined = Math.max(0, Math.min(1, wp.d * degFactor + wp.p * propFactor));
        // ç±»å‹ç¼©æ”¾ï¼Œæå‡éPost/Keywordçš„è§‚æ„Ÿ
        const typeScale = (nodeType === 'Topic') ? 1.1
          : (nodeType === 'Entity' || nodeType === 'User' || nodeType === 'Subreddit') ? 1.05 : 1.0;
        const typeScale2 = (nodeType === 'Topic') ? 1.1
          : (nodeType === 'Entity' || nodeType === 'User' || nodeType === 'Subreddit') ? 1.05 : 1.0;
        combined = Math.min(1, combined * typeScale2);
        
        // è®¡ç®—æœ€ç»ˆå¤§å°ï¼šæœ€å°å¤§å° + (æœ€å¤§å¤§å° - æœ€å°å¤§å°) * å½’ä¸€åŒ–å› å­
        let size = minSize + (maxNodeSize - minSize) * combined;
        
        // åŠ¨æ€åº•çº¿ï¼šéšåº¦æ•°ç¼“æ…¢æå‡ï¼Œé¿å…ä¿¡æ¯é‡å¤§çš„èŠ‚ç‚¹è¿‡å°
        let dynBump = 0.8 * Math.sqrt(Math.max(0, degree));
        if (nodeType === 'SentimentTag') {
          // é™ä½åº•çº¿æå‡å¹…åº¦ï¼Œé¿å…å°ºå¯¸è¢«åº•çº¿æŠ¹å¹³å·®å¼‚
          const bump = Math.min(3, 0.6 * Math.sqrt(Math.max(0, degree)));
          const floor = (degree > 0 ? 18 : 16) + bump;
          if (size < floor) size = floor;
        }
        if (nodeType === 'Topic') {
          const floor = (degree > 0 ? 20 : 16) + Math.min(6, dynBump);
          if (size < floor) size = floor;
        }
        if (nodeType === 'Entity' || nodeType === 'User' || nodeType === 'Subreddit') {
          const floor = (degree > 0 ? 16 : 14) + Math.min(4, dynBump);
          if (size < floor) size = floor;
        }
        
        return Math.round(size);
      }

      // å…¨å±åŠŸèƒ½ - æå–è§†å›¾åˆ°å…¨å±å®¹å™¨
      let isFullscreen = false;
      let fullscreenChart = null;
      
      window.toggleSocialFullscreen = function() {
        const fullscreenView = document.getElementById('graph-fullscreen-view');
        const originalContainer = document.getElementById('social-graph-container');
        const originalChart = document.getElementById('graph-chart');
        const fullscreenContainer = document.getElementById('fullscreen-graph-container');
        const fullscreenChartEl = document.getElementById('fullscreen-graph-chart');
        const icon = document.getElementById('social-fullscreen-icon');
        const text = document.getElementById('social-fullscreen-text');
        
        if (isFullscreen) {
          // é€€å‡ºå…¨å±
          console.log('é€€å‡ºå…¨å±');
          isFullscreen = false;
          fullscreenView.classList.remove('active');
          
          // é”€æ¯å…¨å±å›¾è¡¨
          if (fullscreenChart) {
            fullscreenChart.dispose();
            fullscreenChart = null;
          }
          
          // æ¢å¤åŸå›¾è¡¨æ˜¾ç¤º
          if (originalChart) {
            originalChart.style.display = 'block';
          }
          
          // é€šçŸ¥çˆ¶çª—å£æ˜¾ç¤ºä¾§è¾¹æ 
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ type: 'fullscreen', action: 'exit' }, '*');
              console.log('å·²é€šçŸ¥çˆ¶çª—å£æ˜¾ç¤ºä¾§è¾¹æ ');
            }
          } catch (e) {
            console.error('é€šçŸ¥çˆ¶çª—å£å¤±è´¥:', e);
          }
          
          // æ›´æ–°æŒ‰é’®çŠ¶æ€
          if (icon) icon.textContent = 'â›¶';
          if (text) text.textContent = 'å…¨å±';
          
          // é‡æ–°è°ƒæ•´åŸå›¾è¡¨å¤§å°
          if (graphChart) {
            setTimeout(() => {
              graphChart.resize();
            }, 100);
          }
        } else {
          // è¿›å…¥å…¨å±
          console.log('è¿›å…¥å…¨å±');
          isFullscreen = true;
          
          // éšè—åŸå›¾è¡¨
          if (originalChart) {
            originalChart.style.display = 'none';
          }
          
          // æ˜¾ç¤ºå…¨å±è§†å›¾
          fullscreenView.classList.add('active');
          
          // é€šçŸ¥çˆ¶çª—å£éšè—ä¾§è¾¹æ 
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ type: 'fullscreen', action: 'enter' }, '*');
              console.log('å·²é€šçŸ¥çˆ¶çª—å£éšè—ä¾§è¾¹æ ');
            }
          } catch (e) {
            console.error('é€šçŸ¥çˆ¶çª—å£å¤±è´¥:', e);
          }
          
          // å¤åˆ¶å›¾è¡¨é…ç½®åˆ°å…¨å±å®¹å™¨
          if (graphChart && currentGraphData) {
            // è·å–å½“å‰å›¾è¡¨é…ç½®
            const option = graphChart.getOption();
            
            // åˆ›å»ºæ–°çš„å›¾è¡¨å®ä¾‹
            fullscreenChart = echarts.init(fullscreenChartEl);
            fullscreenChart.setOption(option);
            
            // é‡æ–°è°ƒæ•´å¤§å°
            setTimeout(() => {
              fullscreenChart.resize();
            }, 100);
            
            // å¤åˆ¶ç‚¹å‡»äº‹ä»¶
            fullscreenChart.on('click', (params) => {
              if (params.dataType === 'node') {
                const nodeData = nodeDataMap[params.data.id];
                if (nodeData && nodeData.type === 'Post') {
                  showPostDetail(nodeData);
                }
              }
            });
          }
          
          // æ›´æ–°æŒ‰é’®çŠ¶æ€
          if (icon) icon.textContent = 'â›¶';
          if (text) text.textContent = 'é€€å‡ºå…¨å±';
        }
      };

      // ç›‘å¬ESCé”®é€€å‡ºå…¨å±
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isFullscreen) {
          toggleSocialFullscreen();
        }
      });

      // ç›‘å¬çˆ¶çª—å£çš„å…¨å±çŠ¶æ€å˜åŒ–
      window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'fullscreen-state') {
          if (!e.data.isFullscreen && isFullscreen) {
            // çˆ¶çª—å£é€€å‡ºå…¨å±ï¼ŒåŒæ­¥çŠ¶æ€
            const container = document.getElementById('social-graph-container');
            const icon = document.getElementById('social-fullscreen-icon');
            const text = document.getElementById('social-fullscreen-text');
            isFullscreen = false;
            container.classList.remove('fullscreen');
            icon.textContent = 'â›¶';
            text.textContent = 'å…¨å±';
            if (graphChart) {
              setTimeout(() => {
                graphChart.resize();
              }, 100);
            }
          }
        }
      });

      // ä¿ç•™åŸå‡½æ•°ä»¥å¤‡åç”¨ï¼ˆå·²åºŸå¼ƒï¼‰
      function getNodeSize(nodeType, properties) {
        const baseSize = {
          'Post': 30,
          'Keyword': 20,
          'Entity': 25,
          'Topic': 35,
          'SentimentTag': 15,
          'User': 20,
          'Subreddit': 25
        };
        const size = baseSize[nodeType] || 20;
        const weight = properties?.weight || 1;
        return Math.max(size * 0.5, Math.min(size * 2, size * Math.sqrt(weight)));
      }

      // è·å–èŠ‚ç‚¹é¢œè‰²
      function getNodeColor(nodeType) {
        const colors = {
          'Post': '#2563eb',
          'Keyword': '#10b981',
          'Entity': '#f59e0b',
          'Topic': '#8b5cf6',
          'SentimentTag': '#ec4899',
          'User': '#64748b',
          'Subreddit': '#14b8a6'
        };
        return colors[nodeType] || '#94a3b8';
      }

      let lastCategories = [];
      function getNodeTypeName(categoryIndex) {
        return lastCategories[categoryIndex]?.name || 'Unknown';
      }
      
      // ä¸åŒç±»å‹èŠ‚ç‚¹å½¢çŠ¶
      function getNodeSymbol(nodeType) {
        const map = {
          'Post': 'circle',
          'Keyword': 'diamond',
          'Entity': 'rect',
          'Topic': 'triangle',
          'SentimentTag': 'pin',
          'User': 'roundRect',
          'Subreddit': 'arrow'
        };
        return map[nodeType] || 'circle';
      }

      // ===== æƒ…ç»ªé¢œè‰²å·¥å…· =====
      function hexToRgb(hex) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return m ? {
          r: parseInt(m[1], 16),
          g: parseInt(m[2], 16),
          b: parseInt(m[3], 16)
        } : { r: 148, g: 163, b: 184 };
      }
      function rgbToHex(r, g, b) {
        const toHex = (v) => v.toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }
      // value âˆˆ [-1,1]ï¼š-1 è´Ÿï¼ˆçº¢ï¼‰ï¼Œ0 ä¸­æ€§ï¼ˆç°ï¼‰ï¼Œ+1 æ­£ï¼ˆç»¿ï¼‰
      function sentimentColor(value) {
        const neg = hexToRgb('#ef4444');
        const neu = hexToRgb('#94a3b8');
        const pos = hexToRgb('#10b981');
        if (value === 0) return '#94a3b8';
        if (value > 0) {
          const t = Math.min(1, Math.max(0, value));
          const r = Math.round(neu.r + (pos.r - neu.r) * t);
          const g = Math.round(neu.g + (pos.g - neu.g) * t);
          const b = Math.round(neu.b + (pos.b - neu.b) * t);
          return rgbToHex(r, g, b);
        } else {
          const t = Math.min(1, Math.max(0, -value));
          const r = Math.round(neu.r + (neg.r - neu.r) * t);
          const g = Math.round(neu.g + (neg.g - neu.g) * t);
          const b = Math.round(neu.b + (neg.b - neu.b) * t);
          return rgbToHex(r, g, b);
        }
      }

      // æ˜¾ç¤ºPostè¯¦æƒ… - ç›´æ¥è°ƒç”¨æ•°æ®åº“ç®¡ç†API
      async function showPostDetail(nodeData) {
        const modal = document.getElementById('post-modal');
        const content = document.getElementById('post-detail-content');
        const postId = nodeData.id;
        
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        content.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;">åŠ è½½ä¸­...</div>';
        modal.style.display = 'block';
        
        try {
          // è°ƒç”¨æ•°æ®åº“ç®¡ç†APIè·å–å®Œæ•´æ–‡æ¡£æ•°æ®ï¼ˆMarketApp.fetchJSON è‡ªåŠ¨è§£æ envelopeï¼‰
          const doc = await window.MarketApp.fetchJSON(`/api/v1/admin/documents/${postId}`);
          
          // å¤„ç† extracted_dataï¼šå¦‚æœæ˜¯å­—ç¬¦ä¸²åˆ™è§£æä¸ºå¯¹è±¡
          let extractedData = doc.extracted_data;
          if (typeof extractedData === 'string') {
            try {
              extractedData = JSON.parse(extractedData);
            } catch (e) {
              console.error('è§£æ extracted_data å¤±è´¥:', e);
              extractedData = {};
            }
          }
          
          const extracted = extractedData || {};
          
          // ä½¿ç”¨ä¸æ•°æ®åº“ç®¡ç†é¡µé¢ç›¸åŒçš„æ ¼å¼
          const bodyHtml = `
            <div><strong>æ ‡é¢˜:</strong> ${escapeHtml(doc.title || '(æ— )')}</div>
            <div style="margin-top: 12px;"><strong>URL:</strong> <a href="${doc.uri}" target="_blank" class="link">${escapeHtml(doc.uri)}</a></div>
            ${window.renderGraphExtractedCard ? window.renderGraphExtractedCard(extractedData || {}, escapeHtml) : ''}
            ${extracted.text || doc.content ? `
              <div style="margin-top: 16px;">
                <strong>å†…å®¹:</strong>
                <div class="content-preview">${escapeHtml((extracted.text || doc.content || '').substring(0, 5000))}${(extracted.text || doc.content || '').length > 5000 ? '...' : ''}</div>
              </div>
            ` : ''}
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
              <div style="font-size: 12px; color: #6b7280;">
                <div><strong>åˆ›å»ºæ—¶é—´:</strong> ${doc.created_at ? new Date(doc.created_at).toLocaleString('zh-CN') : '-'}</div>
                <div style="margin-top: 8px;"><strong>æ›´æ–°æ—¶é—´:</strong> ${doc.updated_at ? new Date(doc.updated_at).toLocaleString('zh-CN') : '-'}</div>
              </div>
            </div>
          `;
          
          content.innerHTML = bodyHtml;
        } catch (err) {
          console.error('åŠ è½½æ–‡æ¡£è¯¦æƒ…å¤±è´¥:', err);
          content.innerHTML = `<div class="error">åŠ è½½å¤±è´¥: ${escapeHtml(err.message)}</div>`;
        }
      }

      // å…³é—­Postè¯¦æƒ…æ¨¡æ€æ¡†
      function closePostModal() {
        const modal = document.getElementById('post-modal');
        modal.style.display = 'none';
      }

      // HTMLè½¬ä¹‰å‡½æ•°
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
      window.onclick = function(event) {
        const modal = document.getElementById('post-modal');
        if (event.target === modal) {
          closePostModal();
        }
      }

      // åˆå§‹åŒ–
      window.addEventListener('DOMContentLoaded', () => {
        // åˆå§‹åŒ–å›¾è¡¨
        initChart();
        loadGraphDocTypeHint();
        // é»˜è®¤åŠ è½½å…¨éƒ¨æ•°æ®ï¼Œç”¨æˆ·å¯å†ç­›é€‰
        loadGraph();
      });
    </script>
  </body>
</html>

