<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>å¸‚åœºæ•°æ®å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="/static/js/app-shell.js"></script>
    <style>
      * { box-sizing: border-box; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        margin: 0;
        padding: 24px;
        background: #f8fafc;
        color: #1e293b;
        line-height: 1.6;
      }
      body.in-iframe header {
        margin-bottom: 0;
        border-radius: 0;
      }
      .container {
        max-width: 100%;
        margin: 0 auto;
        width: 100%;
      }
      header {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 28px;
        color: #0f172a;
      }
      header p {
        margin: 0;
        color: #64748b;
      }
      section {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      section h2 {
        margin: 0 0 16px 0;
        font-size: 18px;
        color: #0f172a;
        border-bottom: 2px solid #e2e8f0;
        padding-bottom: 10px;
      }
      .chart-container {
        position: relative;
        height: 240px;
        margin-bottom: 16px;
      }
      .chart-container.large {
        height: 300px;
      }
      .filters {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 16px;
        align-items: center;
      }
      .filters label {
        font-weight: 500;
        color: #475569;
        white-space: nowrap;
      }
      .filters input, .filters select {
        padding: 8px 12px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
      }
      .filters input[type="date"] {
        min-width: 160px;
      }
      .filters button {
        padding: 8px 16px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      .filters button:hover {
        background: #1d4ed8;
      }
      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: #64748b;
      }
      .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #cbd5e1;
        border-top-color: #2563eb;
        border-radius: 50%;
        animation: spin 0.6s linear infinite;
        margin-right: 8px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .error {
        background: #fef2f2;
        border: 1px solid #fecaca;
        color: #991b1b;
        padding: 12px;
        border-radius: 8px;
        margin: 16px 0;
      }
      .refresh-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        flex-wrap: wrap;
        gap: 12px;
      }
      .refresh-controls label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #64748b;
      }
      .refresh-controls input[type="checkbox"] {
        width: auto;
        margin: 0;
      }
      .refresh-controls input[type="number"] {
        width: 80px;
        padding: 6px 8px;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
      }
      .chart-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .nav-links {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 16px;
      }
      .nav-links a {
        padding: 10px 20px;
        background: #2563eb;
        color: white;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 500;
        display: inline-block;
        transition: background 0.2s;
      }
      .nav-links a:hover {
        background: #1d4ed8;
      }
      .graph-container {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      .graph-container h2 {
        margin: 0 0 16px 0;
        font-size: 18px;
        color: #0f172a;
        border-bottom: 2px solid #e2e8f0;
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .graph-header-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .fullscreen-btn {
        padding: 6px 12px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .fullscreen-btn:hover {
        background: #1d4ed8;
      }
      .fullscreen-btn:active {
        transform: scale(0.95);
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
        color: #475569;
        font-size: 13px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        background: #f1f5f9;
        padding: 6px 10px;
        border-radius: 8px;
      }
      .legend-symbol {
        width: 14px;
        height: 14px;
        border-radius: 4px;
      }
      #graph-chart {
        width: 100%;
        height: 700px;
        min-height: 500px;
      }
      /* å…¨å±è§†å›¾å®¹å™¨ */
      #graph-fullscreen-view {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        background: white;
        padding: 20px;
        box-sizing: border-box;
        overflow: auto;
      }
      #graph-fullscreen-view.active {
        display: block;
      }
      #graph-fullscreen-view .graph-container {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        border-radius: 0;
        box-shadow: none;
      }
      #graph-fullscreen-view #fullscreen-graph-chart {
        width: 100%;
        height: calc(100vh - 80px);
        min-height: 500px;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }
      .stat-card {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        border-left: 4px solid #2563eb;
      }
      .stat-card h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #64748b;
        font-weight: 500;
      }
      .stat-card .value {
        font-size: 32px;
        font-weight: 700;
        color: #0f172a;
      }
      .controls {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 24px;
      }
      .controls-row {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 16px;
      }
      .controls-row:last-child {
        margin-bottom: 0;
      }
      .controls label {
        font-weight: 500;
        color: #475569;
        white-space: nowrap;
      }
      .controls input, .controls select {
        padding: 8px 12px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        font-size: 14px;
      }
      .controls input[type="date"] {
        min-width: 160px;
      }
      .controls button {
        padding: 8px 16px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      .controls button:hover {
        background: #1d4ed8;
      }
      .controls button:disabled {
        background: #94a3b8;
        cursor: not-allowed;
      }
      .info {
        background: #eff6ff;
        border: 1px solid #bfdbfe;
        color: #1e40af;
        padding: 12px;
        border-radius: 8px;
        margin: 16px 0;
      }
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        overflow: auto;
      }
      .modal-content {
        background-color: white;
        margin: 5% auto;
        padding: 24px;
        border-radius: 12px;
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 2px solid #e2e8f0;
      }
      .modal-header h2 {
        margin: 0;
        font-size: 24px;
        color: #0f172a;
      }
      .close {
        color: #94a3b8;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
      }
      .close:hover {
        color: #0f172a;
      }
      .extracted-card {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 16px;
        margin-top: 12px;
      }
      .extracted-section {
        margin-bottom: 20px;
      }
      .extracted-section:last-child {
        margin-bottom: 0;
      }
      .extracted-section h3 {
        margin: 0 0 12px 0;
        font-size: 16px;
        color: #1f2937;
        border-bottom: 2px solid #2563eb;
        padding-bottom: 6px;
      }
      .info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }
      .info-item {
        background: white;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
      }
      .info-item label {
        display: block;
        font-size: 12px;
        color: #6b7280;
        margin-bottom: 4px;
        font-weight: 500;
      }
      .info-item .value {
        font-size: 14px;
        color: #1f2937;
        font-weight: 500;
      }
      .tag-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .tag-item {
        background: white;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 500;
        border: 1px solid #e5e7eb;
      }
      .content-preview {
        max-height: 400px;
        overflow-y: auto;
        padding: 12px;
        background: #f9fafb;
        border-radius: 6px;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
      }
      .link {
        color: #2563eb;
        text-decoration: none;
        word-break: break-all;
      }
      .link:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <script>
      if (window.self !== window.top) {
        document.body.classList.add('in-iframe');
      }
    </script>
    <div class="container">
      <header>
        <h1>ğŸ“ˆ å¸‚åœºæ•°æ®å¯è§†åŒ–</h1>
        <p>å½©ç¥¨å¸‚åœºé”€å”®æ•°æ®ä¸è¶‹åŠ¿åˆ†æ</p>
        <p id="graph-doc-type-hint" class="info" style="margin-top: 12px;"></p>
        <p id="graph-structure-hint" class="info" style="margin-top: 8px;"></p>
        <div class="nav-links">
          <a href="market-data-visualization.html#graph">æœ¬é¡µå›¾è°±</a>
          <a href="/graph.html?type=market" class="secondary">ç»Ÿä¸€å›¾è°±ï¼ˆæ–°é¡µï¼‰</a>
        </div>
      </header>

      <section>
        <div class="refresh-controls">
          <h2>å¸‚åœºè¶‹åŠ¿åˆ†æ</h2>
          <div>
            <label>
              <input type="checkbox" id="auto-refresh-market" /> è‡ªåŠ¨åˆ·æ–°
              <input type="number" id="refresh-interval-market" value="30" min="10" max="300" style="margin-left: 8px;" /> ç§’
            </label>
          </div>
        </div>
        <div class="filters">
          <label>å·ï¼š</label>
          <select id="market-filter-state">
            <option value="">å…¨éƒ¨</option>
            <option value="CA">CA</option>
            <option value="NY">NY</option>
            <option value="TX">TX</option>
          </select>
          <label>æ¸¸æˆï¼š</label>
          <select id="market-filter-game">
            <option value="">å…¨éƒ¨</option>
          </select>
          <label>å¼€å§‹æ—¥æœŸï¼š</label>
          <input type="date" id="market-filter-start" />
          <label>ç»“æŸæ—¥æœŸï¼š</label>
          <input type="date" id="market-filter-end" />
          <label>å‘¨æœŸï¼š</label>
          <select id="market-filter-period">
            <option value="daily">æŒ‰æ—¥</option>
            <option value="monthly">æŒ‰æœˆ</option>
          </select>
          <button onclick="loadMarketTrends()">æ›´æ–°</button>
        </div>
        <div class="chart-container large" id="market-trend-chart">
          <div class="loading"><span class="spinner"></span>åŠ è½½ä¸­...</div>
        </div>
        <div class="chart-grid">
          <div class="chart-container" id="market-state-chart">
            <div class="loading"><span class="spinner"></span>åŠ è½½ä¸­...</div>
          </div>
          <div class="chart-container" id="market-game-chart">
            <div class="loading"><span class="spinner"></span>åŠ è½½ä¸­...</div>
          </div>
        </div>
      </section>

      <section id="graph">
        <div class="stats" id="graph-stats">
          <div class="stat-card">
            <h3>èŠ‚ç‚¹æ€»æ•°</h3>
            <div class="value" id="stat-nodes">0</div>
          </div>
          <div class="stat-card">
            <h3>è¾¹æ€»æ•°</h3>
            <div class="value" id="stat-edges">0</div>
          </div>
          <div class="stat-card">
            <h3>å¸‚åœºæ•°æ®èŠ‚ç‚¹</h3>
            <div class="value" id="stat-market-data">0</div>
          </div>
          <div class="stat-card">
            <h3>å·èŠ‚ç‚¹</h3>
            <div class="value" id="stat-states">0</div>
          </div>
          <div class="stat-card">
            <h3>æ¸¸æˆèŠ‚ç‚¹</h3>
            <div class="value" id="stat-games">0</div>
          </div>
          <div class="stat-card">
            <h3>å®ä½“èŠ‚ç‚¹</h3>
            <div class="value" id="stat-entities">0</div>
          </div>
        </div>

        <div class="controls">
          <div class="controls-row">
            <label>å¼€å§‹æ—¥æœŸï¼š</label>
            <input type="date" id="graph-filter-start" />
            <label>ç»“æŸæ—¥æœŸï¼š</label>
            <input type="date" id="graph-filter-end" />
            <label>å·ï¼š</label>
            <select id="graph-filter-state">
              <option value="">å…¨éƒ¨</option>
              <option value="CA">CA</option>
              <option value="NY">NY</option>
              <option value="TX">TX</option>
            </select>
            <label>æ¸¸æˆï¼š</label>
            <input type="text" id="graph-filter-game" placeholder="å¯é€‰ï¼Œå¦‚ï¼šPowerball" />
            <button onclick="loadMarketGraph()">åŠ è½½å›¾è°±</button>
          </div>
          <div class="controls-row">
            <label>
              <input type="checkbox" id="show-market-data" checked /> æ˜¾ç¤ºå¸‚åœºæ•°æ®èŠ‚ç‚¹
            </label>
            <label>
              <input type="checkbox" id="show-states" checked /> æ˜¾ç¤ºå·èŠ‚ç‚¹
            </label>
            <label>
              <input type="checkbox" id="show-games" checked /> æ˜¾ç¤ºæ¸¸æˆèŠ‚ç‚¹
            </label>
            <label>
              <input type="checkbox" id="show-entities" checked /> æ˜¾ç¤ºå®ä½“èŠ‚ç‚¹
            </label>
          </div>
        </div>

        <div class="graph-container" id="market-graph-container">
          <h2>
            å¸‚åœºæ•°æ®å›¾è°±
            <div class="graph-header-actions">
              <button class="fullscreen-btn" id="market-fullscreen-btn" onclick="toggleMarketFullscreen()">
                <span id="market-fullscreen-icon">â›¶</span>
                <span id="market-fullscreen-text">å…¨å±</span>
              </button>
            </div>
          </h2>
          <div class="legend" id="market-graph-legend"></div>
          <div id="graph-chart"></div>
        </div>
      </section>
    </div>

    <!-- å…¨å±è§†å›¾å®¹å™¨ -->
    <div id="graph-fullscreen-view">
      <div class="graph-container" id="fullscreen-graph-container">
        <h2>
          å¸‚åœºæ•°æ®å›¾è°±
          <div class="graph-header-actions">
            <button class="fullscreen-btn" id="fullscreen-exit-btn" onclick="toggleMarketFullscreen()">
              <span>â›¶</span>
              <span>é€€å‡ºå…¨å±</span>
            </button>
          </div>
        </h2>
        <div class="legend" id="fullscreen-market-legend"></div>
        <div id="fullscreen-graph-chart"></div>
      </div>
    </div>

    <!-- å¸‚åœºæ•°æ®è¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="market-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>å¸‚åœºæ•°æ®è¯¦æƒ…</h2>
          <span class="close" onclick="closeMarketModal()">&times;</span>
        </div>
        <div id="market-detail-content"></div>
      </div>
    </div>

    <script>
      const charts = {};
      let refreshTimers = {};

      function formatCurrency(num) {
        if (num == null || num === undefined) return '-';
        if (typeof num !== 'number') num = parseFloat(num);
        if (isNaN(num)) return '-';
        
        const absNum = Math.abs(num);
        const sign = num < 0 ? '-' : '';
        
        if (absNum >= 1000000000) {
          const value = (absNum / 1000000000).toFixed(2).replace(/\.?0+$/, '');
          return sign + '$' + value + 'B';
        } else if (absNum >= 1000000) {
          const value = (absNum / 1000000).toFixed(2).replace(/\.?0+$/, '');
          return sign + '$' + value + 'M';
        } else if (absNum >= 1000) {
          const value = (absNum / 1000).toFixed(2).replace(/\.?0+$/, '');
          return sign + '$' + value + 'K';
        } else {
          return sign + '$' + absNum.toFixed(absNum % 1 === 0 ? 0 : 2).replace(/\.?0+$/, '');
        }
      }

      async function fetchJSON(url) {
        const res = await fetch(url);
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`HTTP ${res.status}: ${text}`);
        }
        return res.json();
      }

      function showError(containerId, message) {
        const container = document.getElementById(containerId);
        container.innerHTML = `<div class="error">âŒ ${message}</div>`;
      }

      function destroyChart(chartId) {
        if (charts[chartId]) {
          charts[chartId].destroy();
          delete charts[chartId];
        }
      }

      async function loadMarketTrends() {
        const state = document.getElementById('market-filter-state').value;
        const game = document.getElementById('market-filter-game').value;
        const start = document.getElementById('market-filter-start').value;
        const end = document.getElementById('market-filter-end').value;
        const period = document.getElementById('market-filter-period').value;
        
        let url = `/api/v1/dashboard/market-trends?period=${period}`;
        if (state) url += `&state=${state}`;
        if (game) url += `&game=${game}`;
        if (start) url += `&start_date=${start}`;
        if (end) url += `&end_date=${end}`;

        try {
          const data = await fetchJSON(url);
          
          const series = Array.isArray(data?.series) ? data.series : [];
          const stateDistribution = Array.isArray(data?.state_distribution) ? data.state_distribution : [];
          const gameDistribution = Array.isArray(data?.game_distribution) ? data.game_distribution : [];
          
          destroyChart('market-trend');
          const trendCtx = document.getElementById('market-trend-chart');
          trendCtx.innerHTML = '<canvas></canvas>';
          charts['market-trend'] = new Chart(trendCtx.querySelector('canvas'), {
            type: 'line',
            data: {
              labels: series.map(s => s.date || ''),
              datasets: [
                {
                  label: 'é”€å”®é¢',
                  data: series.map(s => s.sales_volume || 0),
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37, 99, 235, 0.1)',
                  tension: 0.4,
                },
                {
                  label: 'æ”¶å…¥',
                  data: series.map(s => s.revenue || 0),
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  tension: 0.4,
                },
                {
                  label: 'å¥–æ± ',
                  data: series.map(s => s.jackpot || 0),
                  borderColor: '#f59e0b',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  tension: 0.4,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { position: 'top' },
                tooltip: {
                  callbacks: {
                    label: (ctx) => `${ctx.dataset.label}: ${formatCurrency(ctx.parsed.y)}`,
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: {
                    callback: (value) => formatCurrency(value),
                  },
                },
              },
            },
          });

          destroyChart('market-state');
          const stateCtx = document.getElementById('market-state-chart');
          stateCtx.innerHTML = '<canvas></canvas>';
          charts['market-state'] = new Chart(stateCtx.querySelector('canvas'), {
            type: 'bar',
            data: {
              labels: stateDistribution.map(s => s.state || ''),
              datasets: [{
                label: 'æ€»é”€å”®é¢',
                data: stateDistribution.map(s => s.total_revenue || 0),
                backgroundColor: '#2563eb',
              }],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) => formatCurrency(ctx.parsed.y),
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: {
                    callback: (value) => formatCurrency(value),
                  },
                },
              },
            },
          });

          destroyChart('market-game');
          const gameCtx = document.getElementById('market-game-chart');
          gameCtx.innerHTML = '<canvas></canvas>';
          charts['market-game'] = new Chart(gameCtx.querySelector('canvas'), {
            type: 'pie',
            data: {
              labels: gameDistribution.map(g => g.game || 'æœªçŸ¥'),
              datasets: [{
                data: gameDistribution.map(g => g.count || 0),
                backgroundColor: [
                  '#2563eb', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899',
                ],
              }],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { position: 'bottom' },
              },
            },
          });
        } catch (err) {
          showError('market-trend-chart', err.message);
        }
      }

      function setupAutoRefresh() {
        const checkbox = document.getElementById('auto-refresh-market');
        const intervalInput = document.getElementById('refresh-interval-market');
        
        checkbox.addEventListener('change', function() {
          if (this.checked) {
            const interval = parseInt(intervalInput.value) * 1000;
            refreshTimers['market'] = setInterval(loadMarketTrends, interval);
          } else {
            if (refreshTimers['market']) {
              clearInterval(refreshTimers['market']);
              delete refreshTimers['market'];
            }
          }
        });
        
        intervalInput.addEventListener('change', function() {
          if (checkbox.checked) {
            if (refreshTimers['market']) {
              clearInterval(refreshTimers['market']);
            }
            const interval = parseInt(this.value) * 1000;
            refreshTimers['market'] = setInterval(loadMarketTrends, interval);
          }
        });
      }

      const MARKET_NODE_COLORS = { 'MarketData': '#2563eb', 'State': '#f59e0b', 'Segment': '#10b981', 'Game': '#10b981', 'Entity': '#8b5cf6' };
      let marketGraphConfig = { nodeTypes: ['MarketData', 'State', 'Segment', 'Entity'], nodeLabels: {}, typeLabel: 'å¸‚åœºå›¾è°±' };
      async function loadGraphDocTypeHint() {
        const hintEl = document.getElementById('graph-doc-type-hint');
        const structureEl = document.getElementById('graph-structure-hint');
        const statsEl = document.getElementById('graph-stats');
        const legendEl = document.getElementById('market-graph-legend');
        if (!hintEl || !structureEl) return;
        try {
          const projectKey = window.MarketApp?.getProjectKey?.() || '';
          const query = projectKey ? `?project_key=${encodeURIComponent(projectKey)}` : '';
          const response = await fetch(`/api/v1/project-customization/graph-config${query}`);
          const data = response.ok ? (await response.json())?.data : null;
          const graphDocTypes = data?.graph_doc_types || {};
          const labels = data?.graph_type_labels || {};
          const graphNodeTypes = data?.graph_node_types || {};
          const graphNodeLabels = data?.graph_node_labels || {};
          const graphEdgeTypes = data?.graph_edge_types || {};
          const relationLabels = data?.graph_relation_labels || {};
          const marketTypes = Array.isArray(graphDocTypes.market) ? graphDocTypes.market : ['market'];
          const marketNodeTypes = Array.isArray(graphNodeTypes.market) ? graphNodeTypes.market : ['MarketData', 'State', 'Segment', 'Entity'];
          const marketEdgeTypes = Array.isArray(graphEdgeTypes.market) ? graphEdgeTypes.market : ['IN_STATE', 'HAS_SEGMENT', 'MENTIONS_ENTITY'];
          const marketLabel = labels.market || 'å¸‚åœºå›¾è°±';
          marketGraphConfig = { nodeTypes: marketNodeTypes, nodeLabels: graphNodeLabels, typeLabel: marketLabel };
          hintEl.textContent = `${marketLabel}æ•°æ®ç±»å‹: ${marketTypes.join(', ')}`;
          const edgeLabels = marketEdgeTypes.map((e) => relationLabels[e] ? `${e}(${relationLabels[e]})` : e);
          structureEl.textContent = `èŠ‚ç‚¹ç±»å‹: ${marketNodeTypes.join(', ')}ï¼›å…³ç³»ç±»å‹: ${edgeLabels.join(', ')}`;
          const lbl = (t) => graphNodeLabels[t] || t;
          if (statsEl) {
            statsEl.innerHTML = `<div class="stat-card"><h3>èŠ‚ç‚¹æ€»æ•°</h3><div class="value" id="stat-nodes">0</div></div><div class="stat-card"><h3>è¾¹æ€»æ•°</h3><div class="value" id="stat-edges">0</div></div>` +
              marketNodeTypes.map((t) => `<div class="stat-card"><h3>${lbl(t)}èŠ‚ç‚¹</h3><div class="value" id="stat-${t}">0</div></div>`).join('');
          }
          const legendHtml = marketNodeTypes.map((t) => {
            const color = MARKET_NODE_COLORS[t] || '#94a3b8';
            const label = graphNodeLabels[t] || t;
            return `<div class="legend-item"><span class="legend-symbol" style="background:${color};"></span>${t} ${label}</div>`;
          }).join('');
          if (legendEl) legendEl.innerHTML = legendHtml;
          const fullscreenLegend = document.getElementById('fullscreen-market-legend');
          if (fullscreenLegend) fullscreenLegend.innerHTML = legendHtml;
        } catch (error) {
          hintEl.textContent = 'å½“å‰å›¾è°±ç±»å‹: market';
          structureEl.textContent = 'èŠ‚ç‚¹ç±»å‹: MarketData, State, Segment, Entityï¼›å…³ç³»ç±»å‹: IN_STATE, HAS_SEGMENT, MENTIONS_ENTITY';
        }
      }

      window.addEventListener('DOMContentLoaded', () => {
        loadMarketTrends();
        setupAutoRefresh();
        loadGraphDocTypeHint();
        // åˆå§‹åŒ–å›¾è°±
        initMarketGraph();
        // é»˜è®¤åŠ è½½å…¨éƒ¨æ•°æ®ï¼Œç”¨æˆ·å¯å†ç­›é€‰
        loadMarketGraph();
      });

      // ===== å›¾è°±åŠŸèƒ½ =====
      let marketGraphChart = null;
      let currentGraphData = null;
      let nodeDataMap = {};

      function initMarketGraph() {
        const chartEl = document.getElementById('graph-chart');
        if (!chartEl) return;
        
        if (chartEl.querySelector('.loading') || chartEl.querySelector('.error') || chartEl.querySelector('.info')) {
          chartEl.innerHTML = '';
        }
        
        marketGraphChart = echarts.init(chartEl);
        
        marketGraphChart.setOption({
          title: {
            text: 'è¯·é€‰æ‹©ç­›é€‰æ¡ä»¶å¹¶ç‚¹å‡»"åŠ è½½å›¾è°±"',
            left: 'center',
            top: 'middle',
            textStyle: {
              color: '#94a3b8',
              fontSize: 16
            }
          }
        });
      }

      async function loadMarketGraph() {
        const start = document.getElementById('graph-filter-start').value;
        const end = document.getElementById('graph-filter-end').value;
        const state = document.getElementById('graph-filter-state').value;
        const game = document.getElementById('graph-filter-game').value.trim();
        
        const chartEl = document.getElementById('graph-chart');
        
        if (marketGraphChart) {
          marketGraphChart.dispose();
          marketGraphChart = null;
        }
        chartEl.innerHTML = '<div class="loading"><span class="spinner"></span>åŠ è½½ä¸­...</div>';
        
        try {
          const projectKey = window.MarketApp?.getProjectKey?.() || '';
          const params = new URLSearchParams();
          if (projectKey) params.append('project_key', projectKey);
          if (start) params.append('start_date', start);
          if (end) params.append('end_date', end);
          if (state) params.append('state', state);
          if (game) params.append('game', game);
          params.append('limit', '100');
          const response = await fetch(`/api/v1/admin/market-graph?${params}`);
          
          let graphData;
          if (!response.ok) {
            try {
              const errorData = await response.json();
              if (errorData.nodes !== undefined && errorData.edges !== undefined) {
                graphData = { nodes: errorData.nodes || [], edges: errorData.edges || [] };
              } else {
                throw new Error(errorData.error || `HTTP ${response.status}`);
              }
            } catch (e) {
              console.warn('APIè¿”å›é”™è¯¯ï¼Œä½¿ç”¨ç©ºæ•°æ®:', e);
              graphData = { nodes: [], edges: [] };
            }
          } else {
            graphData = await response.json();
          }
          
          console.log('APIè¿”å›çš„æ•°æ®:', graphData);
          
          if (!graphData.nodes) graphData.nodes = [];
          if (!graphData.edges) graphData.edges = [];
          
          chartEl.innerHTML = '';
          initMarketGraph();
          
          renderMarketGraph(graphData);
          
        } catch (err) {
          console.error('åŠ è½½å›¾è°±å¤±è´¥:', err);
          const chartEl = document.getElementById('graph-chart');
          chartEl.innerHTML = '';
          initMarketGraph();
          
          
          if (document.getElementById('stat-nodes')) document.getElementById('stat-nodes').textContent = '0';
          if (document.getElementById('stat-edges')) document.getElementById('stat-edges').textContent = '0';
          (marketGraphConfig.nodeTypes || []).forEach((t) => {
            const el = document.getElementById('stat-' + t);
            if (el) el.textContent = '0';
          });
          
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error';
          errorDiv.textContent = `åŠ è½½å¤±è´¥: ${err.message}`;
          chartEl.appendChild(errorDiv);
        }
      }

      function renderMarketGraph(graphData) {
        if (!marketGraphChart) {
          console.error('å›¾è¡¨æœªåˆå§‹åŒ–');
          return;
        }
        
        if (!graphData) {
          console.error('å›¾è°±æ•°æ®ä¸ºç©º');
          return;
        }
        
        console.log('å›¾è°±æ•°æ®:', graphData);
        
        const nodes = graphData.nodes || [];
        const edges = graphData.edges || [];
        
        console.log(`èŠ‚ç‚¹æ•°: ${nodes.length}, è¾¹æ•°: ${edges.length}`);
        
        if (document.getElementById('stat-nodes')) document.getElementById('stat-nodes').textContent = nodes.length || 0;
        if (document.getElementById('stat-edges')) document.getElementById('stat-edges').textContent = edges.length || 0;
        (marketGraphConfig.nodeTypes || []).forEach((t) => {
          const el = document.getElementById('stat-' + t);
          if (el) el.textContent = nodes.filter((n) => n.type === t).length || 0;
        });
        
        if (nodes.length === 0) {
          const chartEl = document.getElementById('graph-chart');
          const infoDiv = document.createElement('div');
          infoDiv.className = 'info';
          infoDiv.innerHTML = 'æš‚æ— å›¾è°±æ•°æ®ã€‚è¯·è°ƒæ•´ç­›é€‰æ¡ä»¶æˆ–ç¡®ä¿æ•°æ®åº“ä¸­æœ‰å¸‚åœºæ•°æ®ã€‚';
          chartEl.innerHTML = '';
          chartEl.appendChild(infoDiv);
          return;
        }
        
        const configTypes = marketGraphConfig.nodeTypes || ['MarketData', 'State', 'Segment', 'Entity'];
        const actualTypes = [...new Set(nodes.map((n) => n.type))];
        const allTypes = [...new Set([...configTypes, ...actualTypes])];
        const categoryMap = {};
        allTypes.forEach((t, i) => { categoryMap[t] = i; });
        const categories = allTypes.map((name) => ({ name }));
        
        nodeDataMap = {};
        
        // è®¡ç®—èŠ‚ç‚¹åº¦æ•°
        const nodeDegrees = {};
        nodes.forEach(node => {
          const nodeId = `${node.type}_${node.id}`;
          nodeDegrees[nodeId] = 0;
        });
        
        edges.forEach(edge => {
          const fromId = `${edge.from.type}_${edge.from.id}`;
          const toId = `${edge.to.type}_${edge.to.id}`;
          if (nodeDegrees.hasOwnProperty(fromId)) {
            nodeDegrees[fromId]++;
          }
          if (nodeDegrees.hasOwnProperty(toId)) {
            nodeDegrees[toId]++;
          }
        });
        
        const degrees = Object.values(nodeDegrees);
        const minDegree = Math.min(...degrees, 0);
        const maxDegree = Math.max(...degrees, 1);
        const degreeRange = maxDegree - minDegree || 1;
        
        // è½¬æ¢èŠ‚ç‚¹æ•°æ®
        const echartsNodes = nodes.map(node => {
          const category = categoryMap[node.type] || 0;
          let nodeName = node.id;
          
          if (node.type === 'MarketData') {
            // ä¼˜å…ˆæ˜¾ç¤ºæ ‡é¢˜
            if (node.title && node.title.trim()) {
              nodeName = node.title.trim();
            } else {
              // å¦‚æœæ²¡æœ‰æ ‡é¢˜ï¼Œä½¿ç”¨stateã€gameã€dateç»„åˆ
              const parts = [];
              if (node.state && node.state.trim()) {
                parts.push(node.state.trim());
              }
              if (node.game && node.game.trim()) {
                parts.push(node.game.trim());
              }
              if (node.date) {
                try {
                  const dateStr = new Date(node.date).toLocaleDateString('zh-CN');
                  if (dateStr && dateStr !== 'Invalid Date') {
                    parts.push(dateStr);
                  }
                } catch (e) {
                  // æ—¥æœŸè§£æå¤±è´¥ï¼Œå¿½ç•¥
                }
              }
              
              // å¦‚æœæœ‰ä»»ä½•æœ‰æ„ä¹‰çš„éƒ¨åˆ†ï¼Œç»„åˆå®ƒä»¬ï¼›å¦åˆ™ä½¿ç”¨é»˜è®¤åç§°
              if (parts.length > 0) {
                nodeName = parts.join(' ');
              } else {
                // å°è¯•ä½¿ç”¨source_nameä½œä¸ºåå¤‡
                if (node.source_name) {
                  nodeName = `${node.source_name} #${node.id}`;
                } else {
                  nodeName = `å¸‚åœºæ•°æ® #${node.id}`;
                }
              }
            }
          } else if (node.type === 'State') {
            nodeName = node.name || node.id || 'æœªçŸ¥å·';
          } else if (node.type === 'Game') {
            nodeName = node.name || node.id || 'æœªçŸ¥æ¸¸æˆ';
          } else if (node.type === 'Entity') {
            nodeName = node.canonical_name || node.name || node.id || 'æœªçŸ¥å®ä½“';
          }
          
          // ç¡®ä¿èŠ‚ç‚¹åç§°ä¸ä¸ºç©º
          if (!nodeName || nodeName.trim() === '') {
            nodeName = `${node.type} #${node.id}`;
          }
          
          const nodeId = `${node.type}_${node.id}`;
          nodeDataMap[nodeId] = node;
          
          const degree = nodeDegrees[nodeId] || 0;
          const normalizedDegree = (degree - minDegree) / degreeRange;
          
          return {
            id: nodeId,
            name: nodeName,
            value: degree,
            category: category,
            symbol: getMarketNodeSymbol(node.type),
            symbolSize: getMarketNodeSize(node.type, normalizedDegree, degree, minDegree, maxDegree),
            itemStyle: {
              color: getMarketNodeColor(node.type)
            },
            label: {
              show: true,
              formatter: (params) => {
                const name = params.name || '';
                return name.length > 20 ? name.substring(0, 20) + '...' : name;
              }
            }
          };
        });
        
        // è½¬æ¢è¾¹æ•°æ®
        const edgeRawWeights = edges.map(e => (e.properties && e.properties.weight) || 1);
        const wMin = Math.min(...edgeRawWeights, 1);
        const wMax = Math.max(...edgeRawWeights, 1);
        const wRange = (wMax - wMin) || 1;
        
        const echartsLinks = edges.map(edge => {
          const fromId = `${edge.from.type}_${edge.from.id}`;
          const toId = `${edge.to.type}_${edge.to.id}`;
          const rawW = (edge.properties && edge.properties.weight) ? edge.properties.weight : 1;
          const normW = (rawW - wMin) / wRange;
          const edgeValue = 1 - normW;
          const width = 1 + 2 * normW;
          
          return {
            source: fromId,
            target: toId,
            value: edgeValue,
            lineStyle: {
              width: Math.max(1, Math.min(3, width)),
              curveness: 0,
              color: '#cbd5e1'
            }
          };
        }).filter(link => {
          const sourceExists = echartsNodes.some(n => n.id === link.source);
          const targetExists = echartsNodes.some(n => n.id === link.target);
          return sourceExists && targetExists;
        });
        
        console.log(`è½¬æ¢åèŠ‚ç‚¹æ•°: ${echartsNodes.length}, è¾¹æ•°: ${echartsLinks.length}`);
        
        // æ¸…é™¤å®¹å™¨ä¸­çš„æ‰€æœ‰æç¤ºæ–‡å­—
        const chartEl = document.getElementById('graph-chart');
        if (chartEl) {
          // ç§»é™¤æ‰€æœ‰æç¤ºå…ƒç´ 
          const loadingEl = chartEl.querySelector('.loading');
          const errorEl = chartEl.querySelector('.error');
          const infoEl = chartEl.querySelector('.info');
          if (loadingEl) loadingEl.remove();
          if (errorEl) errorEl.remove();
          if (infoEl) infoEl.remove();
        }
        
        const option = {
          title: {
            show: false  // æ˜ç¡®éšè—titleï¼Œæ¸…é™¤åˆå§‹æç¤ºæ–‡å­—
          },
          tooltip: {
            trigger: 'item',
            formatter: (params) => {
              if (params.dataType === 'node') {
                const nodeData = nodeDataMap[params.data.id];
                const degree = params.data.value || 0;
                let tooltip = `${params.data.name}<br/>ç±»å‹: ${getMarketNodeTypeName(params.data.category)}<br/>è¿æ¥æ•°: ${degree}`;
                if (nodeData && nodeData.type === 'MarketData') {
                  if (nodeData.state) tooltip += `<br/>å·: ${nodeData.state}`;
                  if (nodeData.game) tooltip += `<br/>æ¸¸æˆ: ${nodeData.game}`;
                  if (nodeData.date) tooltip += `<br/>æ—¥æœŸ: ${new Date(nodeData.date).toLocaleDateString('zh-CN')}`;
                  if (nodeData.revenue) tooltip += `<br/>æ”¶å…¥: ${formatCurrency(nodeData.revenue)}`;
                  tooltip += '<br/><span style="color: #64748b; font-size: 12px;">ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…</span>';
                } else if (nodeData && nodeData.type === 'Entity') {
                  if (nodeData.entity_type) tooltip += `<br/>å®ä½“ç±»å‹: ${nodeData.entity_type}`;
                  if (nodeData.canonical_name) tooltip += `<br/>è§„èŒƒåç§°: ${nodeData.canonical_name}`;
                }
                return tooltip;
              } else {
                return `${params.data.source} â†’ ${params.data.target}`;
              }
            }
          },
          legend: { show: false },
          series: [{
            name: 'å¸‚åœºæ•°æ®å›¾è°±',
            type: 'graph',
            layout: 'force',
            data: echartsNodes,
            links: echartsLinks,
            categories: categories,
            roam: true,
            label: {
              show: true,
              position: 'right',
              formatter: '{b}'
            },
            labelLayout: {
              hideOverlap: true
            },
            scaleLimit: {
              min: 0.05,
              max: 3
            },
            lineStyle: {
              color: 'source',
              curveness: 0
            },
            emphasis: {
              focus: 'adjacency',
              lineStyle: {
                width: 10
              }
            },
            force: {
              repulsion: 2000,  // å¢åŠ æ’æ–¥åŠ›ï¼Œè®©ä¸åŒç»„çš„æ•°æ®ç‚¹åˆ†å¼€
              gravity: 0.1,     // å¢åŠ é‡åŠ›ï¼Œè®©èŠ‚ç‚¹æ›´é›†ä¸­
              edgeLength: [80, 200],  // ç¼©çŸ­è¾¹çš„ç†æƒ³é•¿åº¦ï¼Œè®©è¿æ¥çš„èŠ‚ç‚¹æ›´é è¿‘
              layoutAnimation: true,
              // è®©è¿æ¥åˆ°ç›¸åŒState/Gameçš„MarketDataèŠ‚ç‚¹æ›´é è¿‘
              friction: 0.6  // å¢åŠ æ‘©æ“¦åŠ›ï¼Œè®©å¸ƒå±€æ›´ç¨³å®š
            }
          }]
        };
        
        marketGraphChart.setOption(option);
        currentGraphData = graphData;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        marketGraphChart.on('click', (params) => {
          if (params.dataType === 'node') {
            const nodeData = nodeDataMap[params.data.id];
            if (nodeData && nodeData.type === 'MarketData') {
              showMarketDetail(nodeData);
            }
          }
        });
        
        // å¦‚æœå½“å‰æ˜¯å…¨å±çŠ¶æ€ï¼Œæ›´æ–°å…¨å±å›¾è¡¨
        if (isFullscreen && fullscreenChart) {
          fullscreenChart.setOption(option);
          setTimeout(() => {
            fullscreenChart.resize();
          }, 100);
        }
      }

      function getMarketNodeSymbol(nodeType) {
        const map = {
          'MarketData': 'circle',
          'State': 'rect',
          'Game': 'diamond',
          'Entity': 'triangle'
        };
        return map[nodeType] || 'circle';
      }

      function getMarketNodeSize(nodeType, normalizedDegree, degree, minDegree, maxDegree) {
        // åŸºç¡€å¤§å°ï¼ˆæœ€å°èŠ‚ç‚¹å¤§å°ï¼‰
        const baseSize = {
          'MarketData': 12,
          'State': 30,
          'Game': 18,
          'Entity': 15
        };
        // æœ€å¤§å¤§å°ï¼ˆæœ€å¤§èŠ‚ç‚¹å¤§å°ï¼‰
        const maxSize = {
          'MarketData': 50,
          'State': 60,
          'Game': 45,
          'Entity': 40
        };
        
        const minSize = baseSize[nodeType] || 15;
        const maxNodeSize = maxSize[nodeType] || 40;
        
        // å¦‚æœåº¦æ•°ä¸º0ï¼Œç›´æ¥è¿”å›æœ€å°å¤§å°
        if (degree === 0) {
          return minSize;
        }
        
        // æŒ‰èŠ‚ç‚¹ç±»å‹è®¾ç½®ä¸åŒçš„æŒ‡æ•°ï¼Œè®©åº¦æ•°å·®å¼‚æ›´æ˜æ˜¾
        // æŒ‡æ•°è¶Šå°ï¼Œé«˜é“¾æ¥æ•°èŠ‚ç‚¹çš„å·®å¼‚è¶Šæ˜æ˜¾
        const exponentMap = {
          'MarketData': 0.6,  // MarketDataèŠ‚ç‚¹ä½¿ç”¨è¾ƒå°çš„æŒ‡æ•°ï¼Œè®©é«˜é“¾æ¥æ•°èŠ‚ç‚¹æ›´çªå‡º
          'State': 0.5,       // StateèŠ‚ç‚¹ä¿æŒåŸæœ‰æŒ‡æ•°
          'Game': 0.65,       // GameèŠ‚ç‚¹ä½¿ç”¨ä¸­ç­‰æŒ‡æ•°
          'Entity': 0.7       // EntityèŠ‚ç‚¹ä½¿ç”¨è¾ƒå¤§æŒ‡æ•°ï¼Œå·®å¼‚æ›´å¹³æ»‘
        };
        const exponent = exponentMap[nodeType] || 0.6;
        
        // ç¡®ä¿å½’ä¸€åŒ–åº¦æ•°åœ¨ [0, 1] èŒƒå›´å†…
        const clampedNormalizedDegree = Math.max(0, Math.min(1, normalizedDegree));
        
        // åº”ç”¨æŒ‡æ•°å‡½æ•°ï¼šdegreeFactor = normalizedDegree^exponent
        // å½“ exponent < 1 æ—¶ï¼Œé«˜é“¾æ¥æ•°èŠ‚ç‚¹ä¼šè¢«æ”¾å¤§
        const degreeFactor = Math.pow(clampedNormalizedDegree, exponent);
        
        // è®¡ç®—åŸºç¡€å¤§å°ï¼šæœ€å°å¤§å° + (æœ€å¤§å¤§å° - æœ€å°å¤§å°) * éçº¿æ€§å› å­
        let size = minSize + (maxNodeSize - minSize) * degreeFactor;
        
        // å¯¹äºé«˜é“¾æ¥æ•°èŠ‚ç‚¹ï¼Œè¿›ä¸€æ­¥æ”¾å¤§å·®å¼‚
        // æ ¹æ®èŠ‚ç‚¹ç±»å‹è®¾ç½®ä¸åŒçš„æ”¾å¤§é˜ˆå€¼å’Œå¼ºåº¦
        const boostThresholdMap = {
          'MarketData': 0.6,  // MarketDataèŠ‚ç‚¹åœ¨60%ä»¥ä¸Šå°±å¼€å§‹æ”¾å¤§
          'State': 0.7,
          'Game': 0.65,
          'Entity': 0.7
        };
        const boostStrengthMap = {
          'MarketData': 0.8,  // MarketDataèŠ‚ç‚¹ä½¿ç”¨æ›´å¼ºçš„æ”¾å¤§æ•ˆæœ
          'State': 0.5,
          'Game': 0.6,
          'Entity': 0.5
        };
        
        const boostThreshold = boostThresholdMap[nodeType] || 0.7;
        const boostStrength = boostStrengthMap[nodeType] || 0.5;
        
        if (clampedNormalizedDegree > boostThreshold) {
          // å¯¹é«˜é“¾æ¥æ•°èŠ‚ç‚¹ä½¿ç”¨é¢å¤–çš„æ”¾å¤§ç³»æ•°
          const highDegreeBoost = 1.0 + (clampedNormalizedDegree - boostThreshold) * boostStrength;
          size = size * highDegreeBoost;
          // ç¡®ä¿ä¸è¶…è¿‡æœ€å¤§å¤§å°
          size = Math.min(size, maxNodeSize);
        }
        
        // å¯¹äºæœ‰é“¾æ¥çš„èŠ‚ç‚¹ï¼Œè®¾ç½®æœ€å°åº•çº¿ï¼Œç¡®ä¿å¯è¯»æ€§
        // æ ¹æ®èŠ‚ç‚¹ç±»å‹è®¾ç½®ä¸åŒçš„åº•çº¿å€æ•°
        const floorMultiplierMap = {
          'MarketData': 1.3,  // MarketDataèŠ‚ç‚¹æœ‰é“¾æ¥æ—¶è‡³å°‘æ¯”æœ€å°å¤§å°å¤§30%
          'State': 1.2,
          'Game': 1.25,
          'Entity': 1.2
        };
        
        if (degree > 0) {
          const floorMultiplier = floorMultiplierMap[nodeType] || 1.2;
          const minFloor = minSize * floorMultiplier;
          size = Math.max(size, minFloor);
        }
        
        // åŠ¨æ€åº•çº¿ï¼šéšåº¦æ•°ç¼“æ…¢æå‡ï¼Œé¿å…ä¿¡æ¯é‡å¤§çš„èŠ‚ç‚¹è¿‡å°
        // æ ¹æ®èŠ‚ç‚¹ç±»å‹è®¾ç½®ä¸åŒçš„åŠ¨æ€æå‡å¼ºåº¦
        const dynamicBoostMap = {
          'MarketData': 1.2,  // MarketDataèŠ‚ç‚¹ä½¿ç”¨æ›´å¼ºçš„åŠ¨æ€æå‡
          'State': 0.8,
          'Game': 1.0,
          'Entity': 0.9
        };
        
        const dynamicBoost = dynamicBoostMap[nodeType] || 1.0;
        const dynBump = dynamicBoost * Math.sqrt(Math.max(0, degree));
        size = size + dynBump;
        
        // ç¡®ä¿æœ€ç»ˆå¤§å°åœ¨åˆç†èŒƒå›´å†…
        size = Math.max(minSize, Math.min(size, maxNodeSize));
        
        return Math.round(size);
      }

      // å…¨å±åŠŸèƒ½ - æå–è§†å›¾åˆ°å…¨å±å®¹å™¨
      let isFullscreen = false;
      let fullscreenChart = null;
      
      window.toggleMarketFullscreen = function() {
        const fullscreenView = document.getElementById('graph-fullscreen-view');
        const originalContainer = document.getElementById('market-graph-container');
        const originalChart = document.getElementById('graph-chart');
        const fullscreenContainer = document.getElementById('fullscreen-graph-container');
        const fullscreenChartEl = document.getElementById('fullscreen-graph-chart');
        const icon = document.getElementById('market-fullscreen-icon');
        const text = document.getElementById('market-fullscreen-text');
        
        if (isFullscreen) {
          // é€€å‡ºå…¨å±
          console.log('é€€å‡ºå…¨å±');
          isFullscreen = false;
          fullscreenView.classList.remove('active');
          
          // é”€æ¯å…¨å±å›¾è¡¨
          if (fullscreenChart) {
            fullscreenChart.dispose();
            fullscreenChart = null;
          }
          
          // æ¢å¤åŸå›¾è¡¨æ˜¾ç¤º
          if (originalChart) {
            originalChart.style.display = 'block';
          }
          
          // é€šçŸ¥çˆ¶çª—å£æ˜¾ç¤ºä¾§è¾¹æ 
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ type: 'fullscreen', action: 'exit' }, '*');
              console.log('å·²é€šçŸ¥çˆ¶çª—å£æ˜¾ç¤ºä¾§è¾¹æ ');
            }
          } catch (e) {
            console.error('é€šçŸ¥çˆ¶çª—å£å¤±è´¥:', e);
          }
          
          // æ›´æ–°æŒ‰é’®çŠ¶æ€
          if (icon) icon.textContent = 'â›¶';
          if (text) text.textContent = 'å…¨å±';
          
          // é‡æ–°è°ƒæ•´åŸå›¾è¡¨å¤§å°
          if (marketGraphChart) {
            setTimeout(() => {
              marketGraphChart.resize();
            }, 100);
          }
        } else {
          // è¿›å…¥å…¨å±
          console.log('è¿›å…¥å…¨å±');
          isFullscreen = true;
          
          // éšè—åŸå›¾è¡¨
          if (originalChart) {
            originalChart.style.display = 'none';
          }
          
          // æ˜¾ç¤ºå…¨å±è§†å›¾
          fullscreenView.classList.add('active');
          
          // é€šçŸ¥çˆ¶çª—å£éšè—ä¾§è¾¹æ 
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ type: 'fullscreen', action: 'enter' }, '*');
              console.log('å·²é€šçŸ¥çˆ¶çª—å£éšè—ä¾§è¾¹æ ');
            }
          } catch (e) {
            console.error('é€šçŸ¥çˆ¶çª—å£å¤±è´¥:', e);
          }
          
          // å¤åˆ¶å›¾è¡¨é…ç½®åˆ°å…¨å±å®¹å™¨
          if (marketGraphChart && currentGraphData) {
            // è·å–å½“å‰å›¾è¡¨é…ç½®
            const option = marketGraphChart.getOption();
            
            // åˆ›å»ºæ–°çš„å›¾è¡¨å®ä¾‹
            fullscreenChart = echarts.init(fullscreenChartEl);
            fullscreenChart.setOption(option);
            
            // é‡æ–°è°ƒæ•´å¤§å°
            setTimeout(() => {
              fullscreenChart.resize();
            }, 100);
            
            // å¤åˆ¶ç‚¹å‡»äº‹ä»¶
            fullscreenChart.on('click', (params) => {
              if (params.dataType === 'node') {
                const nodeData = nodeDataMap[params.data.id];
                if (nodeData && nodeData.type === 'MarketData') {
                  showMarketDetail(nodeData);
                }
              }
            });
          }
          
          // æ›´æ–°æŒ‰é’®çŠ¶æ€
          if (icon) icon.textContent = 'â›¶';
          if (text) text.textContent = 'é€€å‡ºå…¨å±';
        }
      };

      // ç›‘å¬ESCé”®é€€å‡ºå…¨å±
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isFullscreen) {
          toggleMarketFullscreen();
        }
      });

      // ç›‘å¬çˆ¶çª—å£çš„å…¨å±çŠ¶æ€å˜åŒ–
      window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'fullscreen-state') {
          if (!e.data.isFullscreen && isFullscreen) {
            // çˆ¶çª—å£é€€å‡ºå…¨å±ï¼ŒåŒæ­¥çŠ¶æ€
            const container = document.getElementById('market-graph-container');
            const icon = document.getElementById('market-fullscreen-icon');
            const text = document.getElementById('market-fullscreen-text');
            isFullscreen = false;
            container.classList.remove('fullscreen');
            icon.textContent = 'â›¶';
            text.textContent = 'å…¨å±';
            if (marketGraphChart) {
              setTimeout(() => {
                marketGraphChart.resize();
              }, 100);
            }
          }
        }
      });

      function getMarketNodeColor(nodeType) {
        const colors = {
          'MarketData': '#2563eb',
          'State': '#10b981',
          'Game': '#f59e0b',
          'Entity': '#8b5cf6'
        };
        return colors[nodeType] || '#94a3b8';
      }

      function getMarketNodeTypeName(category) {
        const names = ['MarketData', 'State', 'Game', 'Entity'];
        return names[category] || 'Unknown';
      }

      // æ˜¾ç¤ºå¸‚åœºæ•°æ®è¯¦æƒ… - ç›´æ¥è°ƒç”¨æ•°æ®åº“ç®¡ç†API
      async function showMarketDetail(nodeData) {
        const modal = document.getElementById('market-modal');
        const content = document.getElementById('market-detail-content');
        const docId = nodeData.id;
        
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        content.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;">åŠ è½½ä¸­...</div>';
        modal.style.display = 'block';
        
        try {
          // è°ƒç”¨æ•°æ®åº“ç®¡ç†APIè·å–å®Œæ•´æ–‡æ¡£æ•°æ®ï¼ˆMarketApp.fetchJSON è‡ªåŠ¨è§£æ envelopeï¼‰
          const doc = await window.MarketApp.fetchJSON(`/api/v1/admin/documents/${docId}`);
          
          // å¤„ç† extracted_dataï¼šå¦‚æœæ˜¯å­—ç¬¦ä¸²åˆ™è§£æä¸ºå¯¹è±¡
          let extractedData = doc.extracted_data;
          if (typeof extractedData === 'string') {
            try {
              extractedData = JSON.parse(extractedData);
            } catch (e) {
              console.error('è§£æ extracted_data å¤±è´¥:', e);
              extractedData = {};
            }
          }
          
          const extracted = extractedData || {};
          
          // ä½¿ç”¨ä¸æ•°æ®åº“ç®¡ç†é¡µé¢ç›¸åŒçš„æ ¼å¼
          const bodyHtml = `
            <div><strong>æ ‡é¢˜:</strong> ${escapeHtml(doc.title || '(æ— )')}</div>
            <div style="margin-top: 12px;"><strong>URL:</strong> <a href="${doc.uri}" target="_blank" class="link">${escapeHtml(doc.uri)}</a></div>
            ${renderMarketExtractedData(extracted)}
            ${doc.content ? `
              <div style="margin-top: 16px;">
                <strong>å†…å®¹:</strong>
                <div class="content-preview">${escapeHtml(doc.content.substring(0, 5000))}${doc.content.length > 5000 ? '...' : ''}</div>
              </div>
            ` : ''}
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
              <div style="font-size: 12px; color: #6b7280;">
                <div><strong>åˆ›å»ºæ—¶é—´:</strong> ${doc.created_at ? new Date(doc.created_at).toLocaleString('zh-CN') : '-'}</div>
                <div style="margin-top: 8px;"><strong>æ›´æ–°æ—¶é—´:</strong> ${doc.updated_at ? new Date(doc.updated_at).toLocaleString('zh-CN') : '-'}</div>
              </div>
            </div>
          `;
          
          content.innerHTML = bodyHtml;
        } catch (err) {
          console.error('åŠ è½½æ–‡æ¡£è¯¦æƒ…å¤±è´¥:', err);
          content.innerHTML = `<div class="error">åŠ è½½å¤±è´¥: ${escapeHtml(err.message)}</div>`;
        }
      }

      // æ¸²æŸ“å¸‚åœºæ•°æ®ç»“æ„åŒ–æ•°æ®ï¼ˆä¸admin.htmlä¸­çš„å‡½æ•°ç›¸åŒï¼‰
      function renderMarketExtractedData(extractedData) {
        if (!extractedData || Object.keys(extractedData).length === 0) return '';
        
        const extracted = extractedData || {};
        const market = extracted.market || {};
        const entitiesRelations = extracted.entities_relations || {};
        
        let html = '<div class="extracted-card">';
        
        // å¸‚åœºä¿¡æ¯
        if (Object.keys(market).length > 0) {
          html += '<div class="extracted-section">';
          html += '<h3>ğŸ“Š å¸‚åœºæ•°æ®</h3>';
          html += '<div class="info-grid">';
          
          if (market.state) {
            html += `<div class="info-item">
              <label>å·</label>
              <div class="value">${escapeHtml(market.state)}</div>
            </div>`;
          }
          
          if (market.game) {
            html += `<div class="info-item">
              <label>æ¸¸æˆ</label>
              <div class="value">${escapeHtml(market.game)}</div>
            </div>`;
          }
          
          if (market.report_date) {
            html += `<div class="info-item">
              <label>æŠ¥å‘Šæ—¥æœŸ</label>
              <div class="value">${escapeHtml(market.report_date)}</div>
            </div>`;
          }
          
          if (market.sales_volume !== undefined && market.sales_volume !== null) {
            html += `<div class="info-item">
              <label>é”€å”®é¢</label>
              <div class="value">$${market.sales_volume.toLocaleString()}</div>
            </div>`;
          }
          
          if (market.revenue !== undefined && market.revenue !== null) {
            html += `<div class="info-item">
              <label>æ”¶å…¥</label>
              <div class="value">$${market.revenue.toLocaleString()}</div>
            </div>`;
          }
          
          if (market.jackpot !== undefined && market.jackpot !== null) {
            html += `<div class="info-item">
              <label>å¥–æ± </label>
              <div class="value">$${market.jackpot.toLocaleString()}</div>
            </div>`;
          }
          
          if (market.ticket_price !== undefined && market.ticket_price !== null) {
            html += `<div class="info-item">
              <label>ç¥¨ä»·</label>
              <div class="value">$${market.ticket_price}</div>
            </div>`;
          }
          
          if (market.draw_number) {
            html += `<div class="info-item">
              <label>å¼€å¥–å·ç </label>
              <div class="value">${escapeHtml(market.draw_number)}</div>
            </div>`;
          }
          
          if (market.yoy_change !== undefined && market.yoy_change !== null) {
            const color = market.yoy_change >= 0 ? '#10b981' : '#ef4444';
            html += `<div class="info-item">
              <label>åŒæ¯”å˜åŒ–</label>
              <div class="value" style="color: ${color}">${market.yoy_change >= 0 ? '+' : ''}${market.yoy_change.toFixed(1)}%</div>
            </div>`;
          }
          
          if (market.mom_change !== undefined && market.mom_change !== null) {
            const color = market.mom_change >= 0 ? '#10b981' : '#ef4444';
            html += `<div class="info-item">
              <label>ç¯æ¯”å˜åŒ–</label>
              <div class="value" style="color: ${color}">${market.mom_change >= 0 ? '+' : ''}${market.mom_change.toFixed(1)}%</div>
            </div>`;
          }
          
          html += '</div>';
          
          if (market.key_findings && market.key_findings.length > 0) {
            html += '<div style="margin-top: 12px;"><label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px; font-weight: 500;">å…³é”®å‘ç°</label>';
            html += '<div class="tag-list">';
            market.key_findings.forEach(finding => {
              html += `<span class="tag-item" style="background: #fef3c7; color: #92400e; border-color: #fde68a;">${escapeHtml(finding)}</span>`;
            });
            html += '</div></div>';
          }
          
          html += '</div>';
        }
        
        // å®ä½“å’Œå…³ç³»
        if (entitiesRelations.entities && entitiesRelations.entities.length > 0) {
          html += '<div class="extracted-section">';
          html += '<h3>ğŸ·ï¸ å®ä½“ï¼ˆå›¾è°±èŠ‚ç‚¹ï¼‰</h3>';
          html += '<div class="tag-list">';
          entitiesRelations.entities.forEach(entity => {
            const entityName = entity.canonical_name || entity.text || '';
            const entityType = entity.type || 'UNKNOWN';
            html += `<span class="tag-item" style="background: #dcfce7; color: #166534; border-color: #86efac;" title="ç±»å‹: ${entityType}">${escapeHtml(entityName)}</span>`;
          });
          html += '</div></div>';
        }
        
        if (entitiesRelations.relations && entitiesRelations.relations.length > 0) {
          html += '<div class="extracted-section">';
          html += '<h3>ğŸ”— å…³ç³»ï¼ˆå›¾è°±è¾¹ï¼‰</h3>';
          html += '<div style="display: flex; flex-direction: column; gap: 8px;">';
          entitiesRelations.relations.forEach(relation => {
            html += `<div style="background: white; padding: 10px; border-radius: 6px; border: 1px solid #e5e7eb;">
              <div style="font-size: 13px; color: #1f2937;">
                <strong>${escapeHtml(relation.subject || '')}</strong>
                <span style="color: #6b7280; margin: 0 8px;">${escapeHtml(relation.predicate || '')}</span>
                <strong>${escapeHtml(relation.object || '')}</strong>
              </div>
              ${relation.confidence !== undefined ? `<div style="font-size: 11px; color: #6b7280; margin-top: 4px;">ç½®ä¿¡åº¦: ${(relation.confidence * 100).toFixed(1)}%</div>` : ''}
              ${relation.evidence ? `<div style="font-size: 11px; color: #6b7280; margin-top: 4px; font-style: italic;">è¯æ®: ${escapeHtml(relation.evidence)}</div>` : ''}
            </div>`;
          });
          html += '</div></div>';
        }
        
        html += '</div>';
        return html;
      }

      // å…³é—­å¸‚åœºæ•°æ®è¯¦æƒ…æ¨¡æ€æ¡†
      function closeMarketModal() {
        const modal = document.getElementById('market-modal');
        modal.style.display = 'none';
      }

      // HTMLè½¬ä¹‰å‡½æ•°
      function escapeHtml(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
      window.onclick = function(event) {
        const modal = document.getElementById('market-modal');
        if (event.target === modal) {
          closeMarketModal();
        }
      }
    </script>
  </body>
</html>

